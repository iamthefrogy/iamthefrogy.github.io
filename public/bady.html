<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Badminton Flow Manager</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    :root {
      --bg-dark: #090f1a;
      --card: #0f172a;
      --accent: #47c6ff;
      --accent-strong: #00ffa3;
      --text: #e2e8f0;
      --muted: #94a3b8;
      --danger: #f97316;
      --shadow: 0 18px 45px rgba(0, 0, 0, 0.35);
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, #1b1f3a, var(--bg-dark));
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      color: var(--text);
      display: flex;
      justify-content: center;
      padding: 32px 16px 48px;
    }
    body.tour-locked {
      overflow: hidden;
    }
    .app {
      width: min(1100px, 100%);
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    header {
      background: linear-gradient(120deg, rgba(71, 198, 255, 0.2), rgba(0, 255, 163, 0.15));
      backdrop-filter: blur(16px);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 24px;
      padding: 32px;
      box-shadow: var(--shadow);
    }
    header h1 {
      margin: 0;
      font-size: clamp(28px, 5vw, 40px);
    }
    header p {
      margin: 10px 0 0;
      color: var(--muted);
      font-size: 16px;
    }
    .card {
      background: rgba(15, 23, 42, 0.84);
      border-radius: 22px;
      padding: 24px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      box-shadow: 0 18px 30px rgba(9, 10, 24, 0.55);
    }
    .setup-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 20px;
    }
    label {
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      display: block;
      margin-bottom: 6px;
    }
    input[type="text"],
    input[type="number"] {
      width: 100%;
      padding: 14px 16px;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: rgba(255, 255, 255, 0.03);
      color: var(--text);
      font-size: 16px;
      transition: border 0.2s ease;
    }
    input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(71, 198, 255, 0.2);
    }
    button {
      border: none;
      border-radius: 14px;
      padding: 12px 18px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.2s ease;
      color: #020617;
    }
    button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none;
    }
    button:hover:not(:disabled) {
      transform: translateY(-1.5px);
    }
    .btn-accent {
      background: linear-gradient(120deg, var(--accent) 0%, var(--accent-strong) 100%);
      box-shadow: 0 14px 26px rgba(71, 198, 255, 0.35);
      color: #04121a;
    }
    .btn-ghost {
      background: rgba(255, 255, 255, 0.08);
      color: var(--text);
    }
    .btn-secondary {
      background: rgba(255, 255, 255, 0.12);
      color: var(--text);
      border: 1px solid rgba(255, 255, 255, 0.12);
    }
    .player-actions {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    .player-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 12px;
    }
    .chip {
      padding: 8px 12px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.07);
      font-size: 14px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .chip button {
      padding: 0;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.09);
      border: none;
      font-size: 13px;
      line-height: 1;
      color: var(--text);
    }
    .chip button:hover {
      background: rgba(244, 63, 94, 0.65);
      color: #fff;
    }
    small {
      display: block;
      color: var(--muted);
      margin-top: 6px;
    }
    .status-line {
      margin-top: 12px;
      font-size: 14px;
    }
    .status-line span {
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.05);
    }
    .status-line .warn {
      background: rgba(249, 115, 22, 0.18);
      color: #fed7aa;
    }
    .status-line .ok {
      background: rgba(34, 197, 94, 0.18);
      color: #bbf7d0;
    }
    .status-line .muted {
      color: var(--muted);
    }
    .live {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .section-header {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 16px;
    }
    .court-card {
      border-radius: 20px;
      padding: 18px;
      background: linear-gradient(145deg, rgba(15, 23, 42, 0.9), rgba(4, 12, 24, 0.95));
      border: 1px solid rgba(255, 255, 255, 0.05);
      text-align: left;
      color: var(--text);
      display: flex;
      flex-direction: column;
      gap: 12px;
      width: 100%;
    }
    .court-card:hover {
      box-shadow: 0 16px 30px rgba(0, 0, 0, 0.45);
    }
    .card-tag {
      font-size: 13px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--accent);
    }
    .teams {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 12px;
    }
    .team {
      background: rgba(255, 255, 255, 0.04);
      border-radius: 12px;
      padding: 12px;
      min-height: 64px;
    }
    .team h4 {
      margin: 0 0 6px;
      font-size: 13px;
      letter-spacing: 0.05em;
      color: var(--muted);
      text-transform: uppercase;
    }
    .team p {
      margin: 0;
      font-size: 15px;
      font-weight: 600;
      line-height: 1.35;
    }
    .finish-btn {
      align-self: stretch;
      margin-top: 6px;
      padding: 12px;
      border-radius: 12px;
      border: none;
      font-weight: 600;
      color: #020617;
      background: linear-gradient(120deg, var(--accent) 0%, var(--accent-strong) 100%);
      box-shadow: 0 12px 24px rgba(71, 198, 255, 0.25);
      cursor: pointer;
      transition: transform 0.15s ease, opacity 0.2s ease;
    }
    .finish-btn:hover {
      transform: translateY(-1px);
    }
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(3, 6, 23, 0.72);
      backdrop-filter: blur(8px);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      padding: 20px;
      z-index: 40;
    }
    .modal-overlay.active {
      opacity: 1;
      pointer-events: auto;
    }
    .modal {
      width: min(420px, 100%);
      background: #0f172a;
      border-radius: 20px;
      padding: 26px;
      box-shadow: 0 25px 55px rgba(0, 0, 0, 0.45);
      border: 1px solid rgba(255, 255, 255, 0.08);
      text-align: left;
    }
    .modal h3 {
      margin: 0 0 6px;
    }
    .modal p {
      margin: 0;
      color: var(--muted);
      line-height: 1.5;
    }
    .modal strong {
      display: block;
      margin: 12px 0;
      font-size: 16px;
    }
    .modal-actions {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 18px;
    }
    .modal-actions button {
      width: 100%;
    }
    .modal-actions .btn-secondary {
      background: rgba(255, 255, 255, 0.08);
      color: var(--text);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }
    .court-card.waiting {
      border-style: dashed;
      border-color: rgba(255, 255, 255, 0.18);
    }
    .leaderboard {
      margin-top: 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .leaderboard-row {
      padding: 12px 14px;
      border-radius: 14px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.05);
      font-size: 15px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .leaderboard-row strong {
      font-size: 16px;
    }
    .leaderboard-row span {
      color: var(--muted);
    }
    .chemistry-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 12px;
    }
    .chemistry-row {
      padding: 14px;
      border-radius: 16px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.04);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .chemistry-row-head {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      gap: 8px;
      align-items: center;
    }
    .chemistry-pills {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .chemistry-games {
      font-size: 13px;
      color: var(--muted);
    }
    .chemistry-pill {
      font-size: 13px;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(71, 198, 255, 0.18);
      color: var(--accent);
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }
    .chemistry-pill.alt {
      background: rgba(0, 255, 163, 0.18);
      color: var(--accent-strong);
    }
    .chemistry-chip-groups {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 10px;
    }
    .chemistry-label {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      display: block;
      margin-bottom: 6px;
    }
    .chemistry-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      min-height: 24px;
    }
    .chemistry-chip {
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.05);
      font-size: 13px;
    }
    .chemistry-empty {
      font-size: 13px;
      color: var(--muted);
    }
    .tour-overlay {
      position: fixed;
      inset: 0;
      background: rgba(2, 6, 23, 0.85);
      backdrop-filter: blur(6px);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 60;
    }
    .tour-overlay.active {
      opacity: 1;
      pointer-events: auto;
    }
    .tour-card {
      width: min(460px, 100%);
      background: #0f172a;
      border-radius: 22px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 28px;
      box-shadow: 0 24px 60px rgba(0, 0, 0, 0.55);
    }
    .tour-step-label {
      font-size: 13px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--accent);
      margin: 0 0 8px;
    }
    .tour-card h3 {
      margin: 0 0 8px;
      font-size: 24px;
    }
    .tour-card p {
      margin: 0;
      color: var(--muted);
      line-height: 1.5;
    }
    .tour-illustration {
      width: 100%;
      min-height: 180px;
      border-radius: 18px;
      background: rgba(255, 255, 255, 0.03);
      display: flex;
      align-items: stretch;
      justify-content: center;
      margin-bottom: 16px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      padding: 16px;
    }
    .tour-sample {
      width: 100%;
      border-radius: 14px;
      background: rgba(15, 23, 42, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.05);
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .tour-sample label {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }
    .tour-sample input {
      width: 100%;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: rgba(255, 255, 255, 0.03);
      color: var(--text);
      padding: 10px;
      font-size: 14px;
    }
    .tour-sample .tour-sample-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }
    .tour-sample .tour-chip {
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      font-size: 13px;
    }
    .tour-sample button {
      border: none;
      border-radius: 10px;
      background: linear-gradient(120deg, var(--accent), var(--accent-strong));
      color: #020617;
      font-weight: 600;
      padding: 10px 12px;
      font-size: 14px;
    }
    .tour-sample .tour-court {
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 12px;
      background: linear-gradient(145deg, rgba(15, 23, 42, 0.9), rgba(4, 12, 24, 0.95));
    }
    .tour-sample .tour-team {
      display: flex;
      justify-content: space-between;
      font-size: 13px;
    }
    .tour-sample .tour-teams {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
    }
    .tour-sample .tour-team-card {
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.05);
      padding: 10px;
    }
    .tour-sample .tour-leaderboard-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.05);
      font-size: 14px;
    }
    .tour-sample .tour-chemistry {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .tour-actions {
      margin-top: 20px;
      display: flex;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .tour-actions button {
      flex: 1;
      min-width: 140px;
    }
    .tour-content.animate {
      animation: tourFadeIn 0.4s ease;
    }
    @keyframes tourFadeIn {
      from {
        opacity: 0;
        transform: translateY(8px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    .lb-row-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .lb-meta {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .lb-rank {
      font-size: 13px;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(71, 198, 255, 0.15);
      color: var(--accent);
    }
    .lb-score {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .score-track {
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      overflow: hidden;
    }
    .score-fill {
      height: 100%;
      border-radius: 999px;
      background: linear-gradient(120deg, var(--accent), var(--accent-strong));
      width: 0%;
      transition: width 0.3s ease;
    }
    .waiting-list,
    .completed-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 14px;
    }
    .waiting-player {
      padding: 12px 14px;
      border-radius: 14px;
      background: rgba(255, 255, 255, 0.03);
      display: flex;
      justify-content: space-between;
      font-size: 15px;
    }
    .waiting-player span {
      color: var(--muted);
      font-size: 13px;
    }
    .waiting-remove {
      border: none;
      background: none;
      color: inherit;
      font: inherit;
      font-weight: 600;
      padding: 0;
      cursor: pointer;
      text-align: left;
      transition: color 0.15s ease;
    }
    .waiting-remove:hover,
    .waiting-remove:focus-visible {
      color: var(--danger);
      outline: none;
    }
    .idle-btn {
      align-self: stretch;
      margin-top: 10px;
      padding: 11px 12px;
      border-radius: 12px;
      border: 1px dashed rgba(255, 255, 255, 0.35);
      background: rgba(255, 255, 255, 0.03);
      color: var(--text);
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s ease, transform 0.15s ease, opacity 0.2s ease;
    }
    .idle-btn:hover:not(:disabled) {
      background: rgba(255, 255, 255, 0.08);
      transform: translateY(-1px);
    }
    .idle-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .completed-item {
      padding: 12px 14px;
      border-radius: 14px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.04);
      font-size: 14px;
      color: var(--muted);
    }
    .empty-state {
      padding: 24px;
      text-align: center;
      color: var(--muted);
      border: 1px dashed rgba(255, 255, 255, 0.08);
      border-radius: 18px;
    }
    @media (max-width: 640px) {
      body {
        padding: 24px 14px 40px;
      }
      .teams {
        grid-template-columns: 1fr;
      }
      .card {
        padding: 20px;
      }
      .court-card {
        padding: 16px;
      }
      .player-actions {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Frogy Shuffle & Giggle</h1>
    </header>

    <section class="card">
      <div class="setup-grid">
        <div>
          <label for="player-input">Players</label>
          <input type="text" id="player-input" placeholder="Add a name (or many, separated by commas)">
          <div class="player-actions">
            <button class="btn-accent" id="add-player-btn">+ Add Player</button>
          </div>
          <div class="player-chips" id="player-list"></div>
        </div>
        <div>
          <label for="court-input">Courts Available</label>
          <input type="number" id="court-input" min="1" value="2">
          <div class="player-actions">
            <button class="btn-accent" id="start-btn">Start Rotation</button>
          </div>
          <div class="status-line" id="status-line">
          </div>
        </div>
      </div>
    </section>

    <section class="card live">
      <div class="section-header">
        <div>
          <h2 style="margin:0;">Courts in Play</h2>
          <p style="margin:6px 0 0;color:var(--muted);font-size:15px;">Tap a court to mark it finished &amp; free players.</p>
        </div>
      </div>
      <div id="active-courts" class="grid"></div>
    </section>

    <section class="setup-grid">
      <div class="card">
        <h3 style="margin-top:0;">Live Leaderboard</h3>
        <div id="leaderboard" class="leaderboard"></div>
      </div>
      <div class="card">
        <h3 style="margin-top:0;">Team Chemistry</h3>
        <p style="margin:6px 0 12px;color:var(--muted);font-size:14px;">Track who&apos;s teamed up (partners) and who they&apos;ve battled (opponents).</p>
        <div id="chemistry-board" class="chemistry-list"></div>
      </div>
      <div class="card">
        <h3 style="margin-top:0;">Waiting Lobby</h3>
        <div id="waiting-list" class="waiting-list"></div>
      </div>
      <div class="card">
        <h3 style="margin-top:0;">Completed Games</h3>
        <div id="completed-list" class="completed-list"></div>
      </div>
    </section>
  </div>

  <div class="tour-overlay" id="tour-overlay">
    <div class="tour-card">
      <p class="tour-step-label" id="tour-step-count"></p>
      <div class="tour-content" id="tour-content">
        <div class="tour-illustration" id="tour-illustration"></div>
        <h3 id="tour-title"></h3>
        <p id="tour-body"></p>
      </div>
      <div class="tour-actions">
        <button type="button" class="btn-ghost" id="tour-skip">Skip tour</button>
        <button type="button" class="btn-accent" id="tour-next">Next</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="winner-overlay">
    <div class="modal">
      <h3>Who won this game?</h3>
      <p>Select the pair that finished on top so we can track the leaderboard.</p>
      <div id="winner-options" class="modal-actions"></div>
      <button type="button" class="btn-ghost" id="winner-cancel" style="margin-top:12px;">Cancel</button>
    </div>
  </div>

  <div class="modal-overlay" id="post-match-overlay">
    <div class="modal">
      <h3>What next for this court?</h3>
      <p>Everyone just wrapped up. Keep them waiting for fresh opponents or drop them back in immediately.</p>
      <strong id="post-match-summary"></strong>
      <div class="modal-actions">
        <button type="button" class="btn-accent" id="post-match-replay">Play right away</button>
        <button type="button" class="btn-secondary" id="post-match-rest">Wait in lobby</button>
        <button type="button" class="btn-ghost" id="post-match-cancel">Cancel</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="remove-overlay">
    <div class="modal">
      <h3>Remove from Lobby?</h3>
      <p id="remove-message"></p>
      <div class="modal-actions">
        <button type="button" class="btn-accent" id="remove-confirm">Yes, remove</button>
        <button type="button" class="btn-secondary" id="remove-cancel">Keep waiting</button>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const addPlayerInput = document.getElementById('player-input');
      const addPlayerBtn = document.getElementById('add-player-btn');
      const playerListEl = document.getElementById('player-list');
      const courtInput = document.getElementById('court-input');
      const startBtn = document.getElementById('start-btn');
      const statusLine = document.getElementById('status-line');
      const activeCourtsEl = document.getElementById('active-courts');
      const waitingListEl = document.getElementById('waiting-list');
      const completedListEl = document.getElementById('completed-list');
      const leaderboardEl = document.getElementById('leaderboard');
      const chemistryBoardEl = document.getElementById('chemistry-board');
      const tourOverlay = document.getElementById('tour-overlay');
      const tourStepCountEl = document.getElementById('tour-step-count');
      const tourTitleEl = document.getElementById('tour-title');
      const tourBodyEl = document.getElementById('tour-body');
      const tourNextBtn = document.getElementById('tour-next');
      const tourSkipBtn = document.getElementById('tour-skip');
      const tourContentEl = document.getElementById('tour-content');
      const tourIllustrationEl = document.getElementById('tour-illustration');
      const winnerOverlay = document.getElementById('winner-overlay');
      const winnerOptions = document.getElementById('winner-options');
      const winnerCancelBtn = document.getElementById('winner-cancel');
      const modalOverlay = document.getElementById('post-match-overlay');
      const modalSummary = document.getElementById('post-match-summary');
      const modalReplayBtn = document.getElementById('post-match-replay');
      const modalRestBtn = document.getElementById('post-match-rest');
      const modalCancelBtn = document.getElementById('post-match-cancel');
      const removalOverlay = document.getElementById('remove-overlay');
      const removalMessage = document.getElementById('remove-message');
      const removalConfirmBtn = document.getElementById('remove-confirm');
      const removalCancelBtn = document.getElementById('remove-cancel');

      const state = {
        players: new Map(),
        playerOrder: [],
        sessionActive: false,
        courtCount: 2,
        availableQueue: [],
        activeMatches: [],
        completedMatches: [],
        partnerHistory: new Map(),
        opponentHistory: new Map(),
        playerCounter: 1,
        matchCounter: 1,
        pendingFinish: null,
        pendingAward: null,
        pendingRemoval: null,
        scores: new Map(),
        gamesPlayed: new Map()
      };
      const TOUR_STORAGE_KEY = 'badmintonTourComplete';
      const tourSteps = [
        {
          title: 'Invite the squad',
          body: 'Add everyone joining today. Drop names one-by-one separated list or add name and hit enter.',
          markup: '<div class="tour-sample"><label>Players</label><input type="text" value="Riya, Aarav, Zara, Dev, Kian, Mei, Suraj, Tara, Nikhil" readonly><div class="tour-sample-row" style="flex-wrap:wrap;gap:6px;"><span class="tour-chip">Riya</span><span class="tour-chip">Aarav</span><span class="tour-chip">Zara</span><span class="tour-chip">Dev</span><span class="tour-chip">Kian</span><span class="tour-chip">Mei</span><span class="tour-chip">Suraj</span><span class="tour-chip">Tara</span><span class="tour-chip">Nikhil</span></div></div>'
        },
        {
          title: 'Set the courts',
          body: 'Input number of courts you have booked to start with and click "START ROTATION"',
          markup: '<div class="tour-sample"><label>Courts Available</label><div class="tour-sample-row"><input type="number" value="2" readonly style="max-width:90px;"><button type="button">Start Rotation</button></div><div class="tour-sample-row" style="font-size:12px;color:var(--muted);">Auto-fill keeps two courts spinning.</div></div>'
        },
        {
          title: 'Play the games ',
          body: 'Play games according to pair lists are organised with court numbers.',
          markup: '<div class="tour-sample"><div class="tour-court"><div style="font-size:12px;text-transform:uppercase;color:var(--accent);letter-spacing:0.08em;">Court 1</div><div class="tour-team" style="margin-top:8px;"><span>Riya &amp; Aarav</span><span>üîµ</span></div><div class="tour-team"><span>Zara &amp; Nikhil</span><span>üü¢</span></div></div><div class="tour-court"><div style="font-size:12px;text-transform:uppercase;color:var(--accent);letter-spacing:0.08em;">Court 2</div><div class="tour-team" style="margin-top:8px;"><span>Dev &amp; Mei</span><span></span></div><div class="tour-team"><span>Kian &amp; Tara</span><span></span></div></div></div>'
        },
        {
          title: 'Finish the game',
          body: 'If either game on any court is done, tap "MARK FINISHED" and pick the winning pair to move next.',
          markup: '<div class="tour-sample"><div class="tour-court"><div style="font-size:12px;text-transform:uppercase;color:var(--accent);letter-spacing:0.08em;">Court 1</div><div class="tour-team" style="margin-top:8px;"><span>Riya &amp; Aarav</span><span>Ready</span></div><div class="tour-team"><span>Zara &amp; Nikhil</span><span>Ready</span></div></div><div class="tour-court"><div style="font-size:12px;text-transform:uppercase;color:var(--accent);letter-spacing:0.08em;">Court 2</div><div class="tour-team" style="margin-top:8px;"><span>Dev &amp; Mei</span><span>Playing</span></div><div class="tour-team"><span>Kian &amp; Tara</span><span>Playing</span></div></div></div>'
        },
        {
          title: 'Wait or replay logic',
          body: 'Choose ‚ÄúWAIT IN LOBBY‚Äù to hold the finished until court 2 game ends and when you finsh court 2 game, it will autoamtically mix all players and assign new pairs for each court. If you pick ‚ÄúPlay right away‚Äù, that same court remixes immediately while the other court keeps running.',
          markup: '<div class="tour-sample"><div class="tour-court"><div style="font-size:14px;font-weight:600;">Court 1 done</div><div class="tour-team" style="margin-top:8px;"><span>Riya &amp; Aarav</span><span>Lobby</span></div><div class="tour-team"><span>Zara &amp; Nikhil</span><span>Lobby</span></div><div class="tour-teams" style="margin-top:12px;"><button type="button" style="background:rgba(255,255,255,0.1);color:var(--text);border:1px solid rgba(255,255,255,0.2);">Wait in lobby</button><button type="button">Play right away</button></div></div><div class="tour-court"><div style="font-size:14px;font-weight:600;">Court 2 playing</div><div class="tour-team" style="margin-top:8px;"><span>Dev &amp; Mei</span><span>vs</span></div><div class="tour-team"><span>Kian &amp; Tara</span><span>vs</span></div></div><div style="font-size:12px;color:var(--muted);">When Court 2 taps Mark Finished, all freed players auto-mix into fresh teams.</div></div>'
        },
        {
          title: 'Track chemistry',
          body: 'Leaderboard + Team Chemistry cards show wins, partners, and opponents so play stays fresh.',
          markup: '<div class="tour-sample"><div class="tour-leaderboard-row"><strong>Riya</strong><span>6 pts</span></div><div class="tour-leaderboard-row"><strong>Aarav</strong><span>5 pts</span></div><div class="tour-leaderboard-row"><strong>Mei</strong><span>4 pts</span></div><label>Partners &amp; Opponents</label><div class="tour-chemistry"><span class="tour-chip">Partner: Aarav</span><span class="tour-chip">Partner: Dev</span><span class="tour-chip">Partner: Tara</span><span class="tour-chip">Opponent: Kian</span><span class="tour-chip">Opponent: Mei</span><span class="tour-chip">Opponent: Nikhil</span></div></div>'
        }
      ];
      let tourIndex = 0;

      function hasCompletedTour() {
        try {
          return localStorage.getItem(TOUR_STORAGE_KEY) === 'done';
        } catch (err) {
          return false;
        }
      }

      function markTourCompleted() {
        try {
          localStorage.setItem(TOUR_STORAGE_KEY, 'done');
        } catch (err) {
          // ignore
        }
      }

      function startTour() {
        if (!tourOverlay || hasCompletedTour()) return;
        tourIndex = 0;
        document.body.classList.add('tour-locked');
        tourOverlay.classList.add('active');
        updateTourStep();
      }

      function updateTourStep() {
        if (!tourOverlay) return;
        const step = tourSteps[tourIndex];
        tourStepCountEl.textContent = 'Step ' + (tourIndex + 1) + ' of ' + tourSteps.length;
        tourTitleEl.textContent = step.title;
        tourBodyEl.textContent = step.body;
        if (tourIllustrationEl) {
          tourIllustrationEl.innerHTML = step.markup || '';
        }
        tourNextBtn.textContent = tourIndex === tourSteps.length - 1 ? 'End tour' : 'Next';
        if (tourContentEl) {
          tourContentEl.classList.remove('animate');
          void tourContentEl.offsetWidth;
          tourContentEl.classList.add('animate');
        }
      }

      function advanceTour() {
        if (tourIndex >= tourSteps.length - 1) {
          endTour();
          return;
        }
        tourIndex += 1;
        updateTourStep();
      }

      function endTour() {
        if (!tourOverlay) return;
        markTourCompleted();
        tourOverlay.classList.remove('active');
        document.body.classList.remove('tour-locked');
      }

      function updateStatus(message, tone = 'muted') {
        statusLine.innerHTML = '<span class="' + tone + '">' + message + '</span>';
      }

      function removePlayerRecord(id) {
        state.players.delete(id);
        state.playerOrder = state.playerOrder.filter(pid => pid !== id);
        state.availableQueue = state.availableQueue.filter(pid => pid !== id);
        state.scores.delete(id);
        state.gamesPlayed.delete(id);
      }

      function createPlayer(name) {
        const id = 'p' + state.playerCounter++;
        const player = { id, name: name.trim() };
        state.players.set(id, player);
        state.playerOrder.push(id);
        if (!state.scores.has(id)) {
          state.scores.set(id, 0);
        }
        if (!state.gamesPlayed.has(id)) {
          state.gamesPlayed.set(id, 0);
        }
        return player;
      }

      function handleAddPlayers(rawNames) {
        const names = rawNames.split(',').map(n => n.trim()).filter(Boolean);
        if (!names.length) {
          updateStatus('Type at least one name.', 'warn');
          return;
        }
        names.forEach(name => createPlayer(name));
        addPlayerInput.value = '';
        renderRoster();
        renderLeaderboard();
        if (state.sessionActive) {
          const newPlayers = names.map((_, idx) => state.playerOrder[state.playerOrder.length - names.length + idx]);
          state.availableQueue.push(...newPlayers);
          updateStatus('Added ' + names.length + ' player(s) to the lobby.', 'ok');
          renderWaitingList();
          fillCourts();
        } else {
          updateStatus('Nice! Add everyone, then hit Go.', 'ok');
        }
      }

      function handleRemovePlayer(id) {
        if (state.sessionActive) return;
        removePlayerRecord(id);
        renderRoster();
        renderLeaderboard();
        updateStatus('Removed player from this session.', 'muted');
      }

      function handleLobbyRemoval(id) {
        if (!state.sessionActive) return;
        if (!state.availableQueue.includes(id)) {
          updateStatus('Player is already on court. Wait until they return to the lobby.', 'warn');
          return;
        }
        const info = state.players.get(id);
        if (!info) return;
        openRemovalModal(info);
      }

      function openRemovalModal(info) {
        state.pendingRemoval = { id: info.id, name: info.name };
        removalMessage.innerHTML = 'Remove <strong>' + info.name + '</strong> from today\'s lobby? You can add them again any time.';
        removalOverlay.classList.add('active');
      }

      function closeRemovalModal() {
        removalOverlay.classList.remove('active');
        removalMessage.innerHTML = '';
        state.pendingRemoval = null;
      }

      function confirmRemoval() {
        if (!state.pendingRemoval) return;
        const target = state.pendingRemoval;
        removePlayerRecord(target.id);
        renderRoster();
        renderLeaderboard();
        renderWaitingList();
        updateStatus('Removed ' + target.name + ' from the lobby.', 'muted');
        closeRemovalModal();
      }

      function renderRoster() {
        playerListEl.innerHTML = '';
        if (!state.playerOrder.length) {
          playerListEl.innerHTML = '<p class="empty-state" style="padding:14px;">No players yet.</p>';
          return;
        }
        state.playerOrder.forEach(id => {
          const info = state.players.get(id);
          if (!info) return;
          const chip = document.createElement('span');
          chip.className = 'chip';
          chip.innerHTML = '<span>' + info.name + '</span>';
          if (!state.sessionActive) {
            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.textContent = '√ó';
            removeBtn.title = 'Remove';
            removeBtn.addEventListener('click', () => handleRemovePlayer(id));
            chip.appendChild(removeBtn);
          }
          playerListEl.appendChild(chip);
        });
      }

      function startSession() {
        if (state.sessionActive) {
          updateStatus('Session already rolling. Courts refresh automatically.', 'muted');
          return;
        }
        if (state.playerOrder.length < 4) {
          updateStatus('Need at least four players to start.', 'warn');
          return;
        }
        state.courtCount = Math.max(1, parseInt(courtInput.value, 10) || 1);
        state.availableQueue = [...state.playerOrder];
        state.activeMatches = [];
        state.pendingFinish = null;
        modalOverlay.classList.remove('active');
        state.sessionActive = true;
        startBtn.textContent = 'Rotation Live';
        startBtn.disabled = true;
        updateStatus('Session live. Courts will fill as players free up.', 'ok');
        renderWaitingList();
        fillCourts();
      }

      function handleFinishRequest(matchId) {
        const match = state.activeMatches.find(m => m.id === matchId);
        if (!match) return;
        state.pendingFinish = match;
        state.pendingAward = null;
        openWinnerModal(match);
      }

      function resolveMatchCompletion(match, action = 'wait') {
        const index = state.activeMatches.findIndex(m => m.id === match.id);
        if (index === -1) return;
        state.activeMatches.splice(index, 1);
        recordHistory(match);
        const freedPlayers = match.teams.flat();
        state.completedMatches.unshift({
          id: match.id,
          summary: formatMatchSummary(match),
          time: new Date()
        });
        state.completedMatches = state.completedMatches.slice(0, 8);
        renderCompletedMatches();
        const pushToLobby = () => {
          state.availableQueue.push(...freedPlayers);
          renderWaitingList();
        };
        pushToLobby();
        freedPlayers.forEach(id => {
          state.gamesPlayed.set(id, (state.gamesPlayed.get(id) || 0) + 1);
        });
        renderActiveMatches();
        if (action === 'play') {
          assignCourtSlot(match.courtIndex);
          return;
        }
        if (action === 'wait') {
          updateStatus('Players are chilling in the lobby until others free up.', 'muted');
        }
      }

      function openWinnerModal(match) {
        winnerOptions.innerHTML = '';
        match.teams.forEach((team, idx) => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'btn-accent';
          const names = team.map(id => state.players.get(id)?.name || '‚Äî').join(' & ');
          btn.textContent = names;
          btn.addEventListener('click', () => selectWinner(idx));
          winnerOptions.appendChild(btn);
        });
        winnerOverlay.classList.add('active');
      }

      function closeWinnerModal() {
        winnerOverlay.classList.remove('active');
        winnerOptions.innerHTML = '';
      }

      function selectWinner(teamIdx) {
        if (!state.pendingFinish) return;
        const match = state.pendingFinish;
        const team = match.teams[teamIdx] || [];
        state.pendingAward = { matchId: match.id, players: [...team] };
        awardWin(team);
        closeWinnerModal();
        openPostMatchModal(match);
      }

      function awardWin(players) {
        players.forEach(id => {
          state.scores.set(id, (state.scores.get(id) || 0) + 1);
        });
        renderLeaderboard();
      }

      function revertPendingAward() {
        if (!state.pendingAward) return;
        const { players } = state.pendingAward;
        players.forEach(id => {
          const current = state.scores.get(id) || 0;
          state.scores.set(id, Math.max(0, current - 1));
        });
        state.pendingAward = null;
        renderLeaderboard();
      }

      function finalizePendingMatch(action) {
        if (!state.pendingFinish) return;
        const match = state.pendingFinish;
        closePostMatchModal();
        resolveMatchCompletion(match, action);
        state.pendingFinish = null;
        state.pendingAward = null;
      }

      function openPostMatchModal(match) {
        modalSummary.textContent = formatMatchSummary(match);
        modalOverlay.classList.add('active');
      }

      function closePostMatchModal() {
        modalOverlay.classList.remove('active');
      }

      function recordHistory(match) {
        match.teams.forEach(team => {
          const key = [...team].sort().join('|');
          state.partnerHistory.set(key, (state.partnerHistory.get(key) || 0) + 1);
        });
        const [teamA, teamB] = match.teams;
        teamA.forEach(a => {
          teamB.forEach(b => {
            const key = [a, b].sort().join('|');
            state.opponentHistory.set(key, (state.opponentHistory.get(key) || 0) + 1);
          });
        });
        renderChemistryBoard();
      }

      function fillCourts() {
        if (!state.sessionActive) {
          updateStatus('Start the session first.', 'warn');
          return;
        }
        let created = false;
        for (let slot = 0; slot < state.courtCount; slot++) {
          if (state.activeMatches.some(m => m.courtIndex === slot)) continue;
          const assigned = assignCourtSlot(slot, true);
          if (assigned) {
            created = true;
          } else {
            break;
          }
        }
        if (created) {
          updateStatus('Fresh courts ready. Play on!', 'ok');
        } else if (state.availableQueue.length < 4) {
          updateStatus('Waiting on more players to free up.', 'muted');
        }
      }

      function assignCourtSlot(slot, silent = false) {
        if (!state.sessionActive) {
          if (!silent) updateStatus('Start the session first.', 'warn');
          return false;
        }
        if (state.activeMatches.some(m => m.courtIndex === slot)) {
          if (!silent) updateStatus('Court ' + (slot + 1) + ' is already running.', 'warn');
          return false;
        }
        const next = pickNextMatch();
        if (!next) {
          if (!silent) {
            const need = Math.max(0, 4 - state.availableQueue.length);
            const msg = need > 0
              ? 'Need ' + need + ' more player' + (need === 1 ? '' : 's') + ' before mixing.'
              : 'All combos lately played‚Äîwait for fresh faces.';
            updateStatus(msg, 'muted');
          }
          return false;
        }
        next.courtIndex = slot;
        state.activeMatches.push(next);
        renderActiveMatches();
        renderWaitingList();
        if (!silent) {
          updateStatus('Court ' + (slot + 1) + ' has a fresh matchup.', 'ok');
        }
        return true;
      }

      function pickNextMatch() {
        if (state.availableQueue.length < 4) return null;
        const combos = getCombinations(state.availableQueue, 4);
        const queuePositions = new Map();
        state.availableQueue.forEach((id, idx) => queuePositions.set(id, idx));
        let best = null;
        shuffle(combos).forEach(group => {
          const pairings = [
            [[group[0], group[1]], [group[2], group[3]]],
            [[group[0], group[2]], [group[1], group[3]]],
            [[group[0], group[3]], [group[1], group[2]]]
          ];
          shuffle(pairings).forEach(teams => {
            const rating = scoreConfiguration(teams, group, queuePositions);
            if (
              !best ||
              rating.freshPartners > best.rating.freshPartners ||
              (rating.freshPartners === best.rating.freshPartners && rating.freshOpponents > best.rating.freshOpponents) ||
              (rating.freshPartners === best.rating.freshPartners && rating.freshOpponents === best.rating.freshOpponents && rating.weighted < best.rating.weighted)
            ) {
              best = { teams, group, rating };
            }
          });
        });
        if (!best) return null;
        const selection = new Set(best.group);
        state.availableQueue = state.availableQueue.filter(id => !selection.has(id));
        return {
          id: 'm' + state.matchCounter++,
          teams: best.teams,
          createdAt: new Date()
        };
      }

      function scoreConfiguration(teams, group, queuePositions = null) {
        let freshPartners = 0;
        let freshOpponents = 0;
        let partnerPenalty = 0;
        let opponentPenalty = 0;
        teams.forEach(team => {
          const key = [...team].sort().join('|');
          const seen = state.partnerHistory.get(key) || 0;
          if (seen === 0) {
            freshPartners += 1;
          }
          partnerPenalty += seen;
        });
        const [teamA, teamB] = teams;
        teamA.forEach(a => {
          teamB.forEach(b => {
            const key = [a, b].sort().join('|');
            const seen = state.opponentHistory.get(key) || 0;
            if (seen === 0) {
              freshOpponents += 1;
            }
            opponentPenalty += seen;
          });
        });
        let waitingPenalty = 0;
        if (queuePositions) {
          group.forEach(id => {
            const idx = queuePositions.get(id);
            if (typeof idx === 'number' && idx >= 0) {
              waitingPenalty += idx * 0.1;
            }
          });
        }
        const weighted = partnerPenalty * 1000 + opponentPenalty * 400 + waitingPenalty + Math.random() * 0.01;
        return { freshPartners, freshOpponents, weighted };
      }

      function getCombinations(arr, size) {
        const result = [];
        function helper(start, combo) {
          if (combo.length === size) {
            result.push(combo.slice());
            return;
          }
          for (let i = start; i < arr.length; i++) {
            combo.push(arr[i]);
            helper(i + 1, combo);
            combo.pop();
          }
        }
        helper(0, []);
        return result;
      }

      function shuffle(arr) {
        const list = arr.slice();
        for (let i = list.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [list[i], list[j]] = [list[j], list[i]];
        }
        return list;
      }

      function formatMatchSummary(match) {
        const playersA = match.teams[0].map(id => state.players.get(id)?.name || '').join(' & ');
        const playersB = match.teams[1].map(id => state.players.get(id)?.name || '').join(' & ');
        return playersA + ' vs ' + playersB;
      }

      function renderActiveMatches() {
        activeCourtsEl.innerHTML = '';
        if (!state.sessionActive) {
          activeCourtsEl.innerHTML = '<div class="empty-state">No courts running yet.</div>';
          return;
        }
        for (let idx = 0; idx < state.courtCount; idx++) {
          const match = state.activeMatches.find(m => m.courtIndex === idx);
          if (match) {
            const card = document.createElement('div');
            card.className = 'court-card';
            card.dataset.matchId = match.id;
            card.dataset.courtIndex = idx;
            const teamMarkup = match.teams.map((team, teamIdx) => {
              const names = team.map(id => state.players.get(id)?.name || '‚Äî').join('<br>');
              return '<div class="team"><h4>' + (teamIdx === 0 ? 'Team A' : 'Team B') + '</h4><p>' + names + '</p></div>';
            }).join('');
            card.innerHTML = '<span class="card-tag">Court ' + (idx + 1) + '</span>' +
              '<div class="teams">' + teamMarkup + '</div>' +
              '<small>Tap when this game ends.</small>';
            const finishBtn = document.createElement('button');
            finishBtn.type = 'button';
            finishBtn.className = 'finish-btn';
            finishBtn.textContent = 'Mark Finished';
            finishBtn.addEventListener('click', (evt) => {
              evt.stopPropagation();
              handleFinishRequest(match.id);
            });
            card.appendChild(finishBtn);
            activeCourtsEl.appendChild(card);
          } else {
            const idleCard = document.createElement('div');
            idleCard.className = 'court-card waiting';
            const need = Math.max(0, 4 - state.availableQueue.length);
            const statusMsg = need > 0
              ? 'Need ' + need + ' more player' + (need === 1 ? '' : 's') + ' to free up.'
              : 'Players available in the lobby.';
            idleCard.innerHTML = '<span class="card-tag">Court ' + (idx + 1) + '</span>' +
              '<p style="margin:4px 0 0;font-size:18px;font-weight:600;">Court idle</p>' +
              '<small>' + statusMsg + '</small>';
            const assignBtn = document.createElement('button');
            assignBtn.type = 'button';
            assignBtn.className = 'idle-btn';
            assignBtn.textContent = need > 0 ? 'Need more players' : 'Assign next matchup';
            assignBtn.disabled = need > 0;
            assignBtn.addEventListener('click', (evt) => {
              evt.stopPropagation();
              assignCourtSlot(idx);
            });
            idleCard.appendChild(assignBtn);
            activeCourtsEl.appendChild(idleCard);
          }
        }
      }

      function renderWaitingList() {
        waitingListEl.innerHTML = '';
        if (!state.sessionActive) {
          waitingListEl.innerHTML = '<div class="empty-state">Once you start, the lobby will appear here.</div>';
          return;
        }
        if (!state.availableQueue.length) {
          waitingListEl.innerHTML = '<div class="empty-state">Everyone is on court right now.</div>';
          return;
        }
        state.availableQueue.forEach((id, idx) => {
          const player = state.players.get(id);
          if (!player) return;
          const row = document.createElement('div');
          row.className = 'waiting-player';
          const nameBtn = document.createElement('button');
          nameBtn.type = 'button';
          nameBtn.className = 'waiting-remove';
          nameBtn.textContent = player.name;
          nameBtn.title = 'Remove ' + player.name + ' from the lobby';
          nameBtn.addEventListener('click', (evt) => {
            evt.stopPropagation();
            handleLobbyRemoval(id);
          });
          const spot = document.createElement('span');
          spot.textContent = '#' + (idx + 1) + ' in queue';
          row.appendChild(nameBtn);
          row.appendChild(spot);
          waitingListEl.appendChild(row);
        });
      }

      function renderCompletedMatches() {
        completedListEl.innerHTML = '';
        if (!state.completedMatches.length) {
          completedListEl.innerHTML = '<div class="empty-state">No finished games yet.</div>';
          return;
        }
        state.completedMatches.forEach(match => {
          const row = document.createElement('div');
          row.className = 'completed-item';
          const time = match.time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          row.innerHTML = '<strong style="color:#e2e8f0;">' + match.summary + '</strong><br><span>' + time + '</span>';
          completedListEl.appendChild(row);
        });
      }

      function renderLeaderboard() {
        leaderboardEl.innerHTML = '';
        if (!state.playerOrder.length) {
          leaderboardEl.innerHTML = '<div class="empty-state" style="padding:14px;">Add players to start tracking wins.</div>';
          renderChemistryBoard();
          return;
        }
        const stats = state.playerOrder.map(id => ({
          id,
          name: state.players.get(id)?.name || '‚Äî',
          score: state.scores.get(id) || 0
        }));
        stats.sort((a, b) => {
          if (b.score !== a.score) return b.score - a.score;
          return a.name.localeCompare(b.name);
        });
        const maxScore = Math.max(0, ...stats.map(s => s.score));
        stats.forEach((entry, idx) => {
          const percent = maxScore > 0 ? Math.round((entry.score / maxScore) * 100) : 0;
          const row = document.createElement('div');
          row.className = 'leaderboard-row';
          row.innerHTML = '<div class="lb-row-top">' +
            '<div class="lb-meta"><span class="lb-rank">#' + (idx + 1) + '</span><strong>' + entry.name + '</strong></div>' +
            '<div class="lb-score"><strong>' + entry.score + '</strong><span>pt' + (entry.score === 1 ? '' : 's') + '</span></div>' +
            '</div>' +
            '<div class="score-track"><div class="score-fill" style="width:' + percent + '%"></div></div>';
          leaderboardEl.appendChild(row);
        });
        renderChemistryBoard();
      }

      function renderChemistryBoard() {
        if (!chemistryBoardEl) return;
        chemistryBoardEl.innerHTML = '';
        if (!state.playerOrder.length) {
          chemistryBoardEl.innerHTML = '<div class="empty-state" style="padding:14px;">Add players to see partner &amp; opponent stats.</div>';
          return;
        }
        const partnerSets = new Map();
        const opponentSets = new Map();
        state.playerOrder.forEach(id => {
          partnerSets.set(id, new Set());
          opponentSets.set(id, new Set());
        });
        state.partnerHistory.forEach((count, key) => {
          if (!count) return;
          const [a, b] = key.split('|');
          if (!partnerSets.has(a) || !partnerSets.has(b)) return;
          partnerSets.get(a).add(b);
          partnerSets.get(b).add(a);
        });
        state.opponentHistory.forEach((count, key) => {
          if (!count) return;
          const [a, b] = key.split('|');
          if (!opponentSets.has(a) || !opponentSets.has(b)) return;
          opponentSets.get(a).add(b);
          opponentSets.get(b).add(a);
        });
        state.playerOrder.forEach(id => {
          const info = state.players.get(id);
          if (!info) return;
          const partners = Array.from(partnerSets.get(id) || []);
          const opponents = Array.from(opponentSets.get(id) || []);
          const games = state.gamesPlayed.get(id) || 0;
          const partnerNames = partners
            .map(pid => state.players.get(pid)?.name)
            .filter(Boolean)
            .sort((a, b) => a.localeCompare(b));
          const opponentNames = opponents
            .map(pid => state.players.get(pid)?.name)
            .filter(Boolean)
            .sort((a, b) => a.localeCompare(b));
          const row = document.createElement('div');
          row.className = 'chemistry-row';
          const partnerChips = partnerNames.length
            ? partnerNames.map(name => '<span class="chemistry-chip">' + name + '</span>').join('')
            : '<span class="chemistry-empty">Waiting on first pairing</span>';
          const opponentChips = opponentNames.length
            ? opponentNames.map(name => '<span class="chemistry-chip">' + name + '</span>').join('')
            : '<span class="chemistry-empty">No opponents yet</span>';
          row.innerHTML =
            '<div class="chemistry-row-head">' +
            '<div><strong>' + info.name + '</strong><div class="chemistry-games">' + games + ' game' + (games === 1 ? '' : 's') + '</div></div>' +
            '<div class="chemistry-pills">' +
            '<span class="chemistry-pill">Partners (' + partnerNames.length + ')</span>' +
            '<span class="chemistry-pill alt">Opponents (' + opponentNames.length + ')</span>' +
            '</div>' +
            '</div>' +
            '<div class="chemistry-chip-groups">' +
            '<div><span class="chemistry-label">Partners</span><div class="chemistry-chips">' + partnerChips + '</div></div>' +
            '<div><span class="chemistry-label">Opponents</span><div class="chemistry-chips">' + opponentChips + '</div></div>' +
            '</div>';
          chemistryBoardEl.appendChild(row);
        });
      }

      addPlayerBtn.addEventListener('click', () => handleAddPlayers(addPlayerInput.value));
      addPlayerInput.addEventListener('keydown', (evt) => {
        if (evt.key === 'Enter') {
          evt.preventDefault();
          handleAddPlayers(addPlayerInput.value);
        }
      });
      startBtn.addEventListener('click', startSession);
      courtInput.addEventListener('change', () => {
        const next = Math.max(1, parseInt(courtInput.value, 10) || 1);
        courtInput.value = next;
        state.courtCount = next;
        if (state.sessionActive) {
          fillCourts();
        }
      });
      activeCourtsEl.addEventListener('click', (evt) => {
        const card = evt.target.closest('.court-card');
        if (!card) return;
        const matchId = card.dataset.matchId;
        if (!matchId) return;
        handleFinishRequest(matchId);
      });

      modalReplayBtn.addEventListener('click', () => finalizePendingMatch('play'));
      modalRestBtn.addEventListener('click', () => finalizePendingMatch('wait'));
      modalCancelBtn.addEventListener('click', () => {
        revertPendingAward();
        closePostMatchModal();
        state.pendingFinish = null;
      });

      modalOverlay.addEventListener('click', (evt) => {
        if (evt.target === modalOverlay) {
          revertPendingAward();
          closePostMatchModal();
          state.pendingFinish = null;
        }
      });

      winnerCancelBtn.addEventListener('click', () => {
        closeWinnerModal();
        state.pendingFinish = null;
      });

      winnerOverlay.addEventListener('click', (evt) => {
        if (evt.target === winnerOverlay) {
          closeWinnerModal();
          state.pendingFinish = null;
        }
      });

      removalConfirmBtn.addEventListener('click', confirmRemoval);
      removalCancelBtn.addEventListener('click', closeRemovalModal);
      removalOverlay.addEventListener('click', (evt) => {
        if (evt.target === removalOverlay) {
          closeRemovalModal();
        }
      });

      if (tourNextBtn) {
        tourNextBtn.addEventListener('click', advanceTour);
      }
      if (tourSkipBtn) {
        tourSkipBtn.addEventListener('click', endTour);
      }
      if (tourOverlay) {
        tourOverlay.addEventListener('click', (evt) => {
          if (evt.target === tourOverlay) {
            endTour();
          }
        });
      }

      renderRoster();
      renderActiveMatches();
      renderWaitingList();
      renderCompletedMatches();
      renderLeaderboard();
      startTour();
    })();
  </script>
</body>
</html>
